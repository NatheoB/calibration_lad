---
title: "LAD calibration"
output: 
  html_document:
    toc: true
date: "2025-09-24"
author: "Nath√©o BEAUCHAMP"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)
```

```{r}
library(targets)
library(dplyr)
library(ggplot2)
library(ggforce)
library(BayesianTools)
```

# Motivation of the study

This study aims to calibrate Leaf Area Density (LAD), which is defined as the area of leaves per unit of tree crown volume (in $m^2.m^{-3}$). This parameter forms the basis of numerous process-based forest models, such as physiological models that consider photosynthesis and transpiration (e.g. SurEau by Cochard et al., 2021), and forest gap models that estimate light interception (e.g. ForCEEPS by Morin et al., 2021, and Samsara2 by Courbaud et al., 2015).

Although the leaf area density can be directly estimated from a sample of trees (Stadt & Lieffers, 2000), this method is laborious and difficult to replicate for every tree in a stand. Therefore, indirect methods can be employed, such as model inversion using a hemispherical photograph (Courbaud et al., 2003) or the more recent LiDAR methodology (Wei et al., 2020). However, there is a significant lack of research on LAD in the scientific literature, as there are no large-scale databases containing values for a wide range of European species. Furthermore, the few reported species-specific values vary considerably between studies (Ligot et al., 2014).

The aim of this study is to estimate leaf area density (LAD) for nine different species/groups: Fagus sylvatica, Picea abies, Quercus sp., Carpinus betulus, Pseudotsuga menziesii, Pinus sylvestris, Abies alba, Larix decidua and 'other species'. Additionally, Nock et al. (2008) demonstrated intraspecific variation in LAD, with intracrown leaf area decreasing by up to 40% with increasing tree age. This led us to consider the effect of diameter as well. Finally, as crown dimensions are very sensitive to local competition (Touzot et al., 2025), we hypothesise that LAD may also vary in response to competition.

# Methodology

In this study, we used a model inversion methodology, using the ray-tracing model SamsaraLight (Courbaud et al. 2003). We want to estimate the SamsaraLight tree-level parameter LAD using measurements of transmitted light $PACL_{obs}$ (for percentage of above light canopy), based on hemispherical photographs, within 45 plots of different composition and structures. For each plot, trees are inventoried with their crown dimensions, allowing to derive an estimated transmitted light $PACL_{est}$ on virtual sensors with the ray-tracing model SamsaraLight. By doing so, for each virtual sensor of each plot, we have the observed transmitted light $PACL_{obs}$, and the estimated transmitted light given a tree-level value of LAD $PACL_{est}$.

The aim of the calibration is to find a tree-level LAD model that minimize the error between $PACL_{obs}$ and $PACL_{est}$. To do so, we defined the LAD for a tree $i$, of species $s$ in a plot $p$ as $LAD_{i,s,p} = a_{0,s} + a_{0,p} + a_{1,s}.DBH_i + a_{2,s}.BAH_i + \epsilon$, where $a_{0,s}$ is a species-specific intercept, $a_{0,p}$ is a random hierarchical site effect, nested within an origin effect (4 origins of the plots within UCLouvain, INRAe, Cloture and IRRES), $DBH_i$ is the diameter at breast height of tree $i$ , with the associated estimated species-specific coefficient $a_{1,s}$, $BAH_i$ the competition index of the tree $i$ (*i.e.* the sum of basal area of trees higher than the tree $i$), with the associated estimated species-specific coefficient $a_{2,s}$, and $\epsilon$ the normal error term. We used a Bayesian approach to estimate the posterior distribution of parameters that minimize the log-likelihood between observed and simulated PACL. As computation of $PACL_{est}$ needs an external call of SamsaraLight model, we used the R package 'BayesianTools' to run a MCMC sampling of parameters with the "DREAMzs" sampling algorithm.

For this study, we used the SamsaraLight model with the R package SamsaraLight (Beauchamp et al., work in progress, intended for publication in the Journal of Open Source Software). The SamsaraLight model was initially developed in Java and included in the Capsis simulation platform (SamsaraLightLoader by Gauthier Ligot). It could be called from R software via the "RCapsis" R package (Fortin et al., 2021). To speed up calculation times and make SamsaraLight easier to use in an R environment, we created the "SamsaraLight" R package. The source code is written in C++ to enable fast calculations and communication with the R environment is handled by the Rcpp package (Eddelbuettel & Balamuta, 2018). The "SamsaRaLight" R package reduces calculation time compared to the previous method (the RCapsis R package calling the Java model SamsaRaLightLoader) as it does not require the creation of a Java server nor Java objects. It also facilitates the use of SamsaraLight within R, as it does not require the creation of an inventory file, instead using R objects and functions directly. The package is functional and stored in a GitHub repository, but it is still subject to private restrictions as discussions regarding co-authorship and the intellectual property rights of the source code need to be concluded.

# Calibration plots

The 45 calibration plots comes from 4 different sources we wiil call IRRES (9 plots, Gauthier Ligot), CLOTURE (23 plots, Gauthier Ligot), INRAe (10 plots, Philippe Balandier) and UCLouvain (3 plots, Mathieu Jonard).

```{r}
plot_stand <- function(init_db, site, cell_size) {
  
  # Get trees inventory
  tmp_data_trees <- init_db$trees[[site]] %>% 
    dplyr::left_join(init_db$species[[site]], 
                     by = c("SpCode" = "SpCode_SamsaraLL")) %>% 
    dplyr::mutate(crown_type = "8E") %>% 
    dplyr::select(id_tree = Id, 
                  species_code = SpCode,
                  species_calib = sp_calib,
                  x = X, y = Y, dbh_cm = Dbh,
                  crown_type, h_m = H, hbase_m = CBH, hmax_m = CMRH,
                  rn_m = RN, rs_m = RS, re_m = RE, rw_m = RW,
                  crown_openess = CrownOpenness, crown_lad = LAD)
  
  
  # If the plot extent dataframe is empty, set it to the default one
  tmp_plot_extent <- init_db$plot_extents[[site]]
  
  if (!is.null(tmp_plot_extent)) {
    tmp_plot_extent <- tmp_plot_extent %>% 
      dplyr::select(x = X, y = Y)
  }
  
  use_rect_zone <- ifelse(is.null(tmp_plot_extent), TRUE, FALSE)
  
  
  # Create a square plot with the inventory in the center
  tmp_stand <- SamsaRaLight::create_rect_stand(tmp_data_trees, 
                                               cell_size, 
                                               tmp_plot_extent,
                                               use_rect_zone,
                                               fill_around = FALSE)
  
  
  # Add sensors and shift coordinates inside the rect stand
  tmp_stand$sensors <- init_db$sensors[[site]] %>% 
    dplyr::select(id_sensor = id, x, y, h_m = z) %>% 
    dplyr::mutate(
      x = x + tmp_stand$info$shift_x,
      y = y + tmp_stand$info$shift_y
    )
  
  # Add species information to the tree dataset
  data_plot <- init_db$plots %>% dplyr::filter(name == site)
  data_species <- init_db$species[[site]]
  
  data_trees <- tmp_stand$trees %>% 
    dplyr::left_join(data_species,
                     by = c("species_code" = "SpCode_SamsaraLL")) %>% 
    dplyr::mutate(Essence_Latin = factor(Essence_Latin, levels = data_species$Essence_Latin))
  
  
  ## Create cell dataframe
  cells_xcenter <- seq(tmp_stand$info$cell_size / 2, 
                       tmp_stand$info$cell_size * tmp_stand$info$n_cells_x - tmp_stand$info$cell_size / 2,
                       by = tmp_stand$info$cell_size)
  
  cells_ycenter <- seq(tmp_stand$info$cell_size / 2, 
                       tmp_stand$info$cell_size * tmp_stand$info$n_cells_y - tmp_stand$info$cell_size / 2,
                       by = tmp_stand$info$cell_size)
  
  data_cells <- expand.grid(
    x_center = cells_xcenter,
    y_center = cells_ycenter
  )
  
  
  # Create the plot
  stand_plot <- ggplot() +
    coord_equal() +
    
    # CELLS 
    geom_tile(data = data_cells, 
              mapping = aes(x = x_center, y = y_center), 
              fill = "white", color = "darkgray")
  
  
  # CORE POLYGON
  if (!is.null(tmp_stand$inv_zone_df)) {  
    stand_plot <- stand_plot +
      geom_polygon(data = tmp_stand$inv_zone_df,
                   mapping = aes(x = x, y = y),
                   fill = "yellow", color = "black", alpha = 0.5)
  }
  
  
  # TREES
  stand_plot <- stand_plot +
    geom_ellipse(data = data_trees, 
                 mapping = aes(x0 = x, y0 = y, 
                               a = (re_m + rw_m) / 2,
                               b = (rn_m + rs_m) / 2,
                               angle = 0,
                               fill = Essence_Latin)) +
    scale_fill_manual(values = data_species$Couleur) +
    labs(fill = "Species") +
    
    # SENSORS
    geom_rect(data = tmp_stand$sensors,
              mapping = aes(xmin = x - 0.5,
                            ymin = y - 0.5,
                            xmax = x + 0.5,
                            ymax = y + 0.5),
              color = "red", fill = "black") +
    
    # GRAPHIC
    scale_x_continuous(breaks = seq(0, tmp_stand$info$n_cells_x * tmp_stand$info$cell_size,
                                    by = tmp_stand$info$cell_size),
                       labels = round(seq(0, tmp_stand$info$n_cells_x * tmp_stand$info$cell_size,
                                          by = tmp_stand$info$cell_size),
                                      digits = 1)) +
    scale_y_continuous(breaks = seq(0, tmp_stand$info$n_cells_y * tmp_stand$info$cell_size,
                                    by = tmp_stand$info$cell_size),
                       labels = round(seq(0, tmp_stand$info$n_cells_y * tmp_stand$info$cell_size,
                                          by = tmp_stand$info$cell_size),
                                      digits = 1)) +
    xlab("") + ylab("") +
    
    labs(title = site,
         subtitle = paste0(round(tmp_stand$info$core_area_ha, 2), "ha - ",
                           round(tmp_stand$info$core_batot_m2ha, 2), "m2/ha - ",
                           nrow(tmp_stand$trees), "trees",
                           "\n",
                           "(long ", round(data_plot$longitude, 2), ", lat ", 
                           round(data_plot$latitude, 2), ") - ",
                           "slope = ", round(data_plot$slope, 1), 
                           ", aspect = ", round(data_plot$aspect),
                           ", northToX = ", round(data_plot$northToX))) +
    
    theme_minimal() +
    theme(panel.grid.minor = element_blank(),
          legend.position = "right",
          plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5)) 
  
  # Print plot
  plot(stand_plot)
}
```

```{r}
# Get data
tar_load(init_db)

# Set the cell size, which will not impact the study as we compute light only on sensors
cell_size <- 10

# Sites names
site_names <- init_db$plots$name
```

## IRRES

```{r}
for (site in site_names[grepl("IRRES", site_names)]) {
  plot_stand(init_db, site, cell_size)
}
```

## CLOTURE

```{r}
for (site in site_names[grepl("Cloture", site_names)]) {
  plot_stand(init_db, site, cell_size)
}
```

## INRAe

```{r}
for (site in site_names[unique(c(grep("Ventoux", site_names), grep("Lorris", site_names),  grep("Fontfreyde", site_names)))]) {
  plot_stand(init_db, site, cell_size)
}
```

## UCLouvain

```{r}
for (site in site_names[grepl("Baileux", site_names)]) {
  plot_stand(init_db, site, cell_size)
}
```

# Preliminary analysis

```{r}
tar_load(lads_method1)
```

As a preliminary analysis, we tried to fit a mean LAD value for each sensor of each site. To do so, we run the SamsaraLight model on each stand by fixing the same crown LAD values of each tree, and for each sensor, we computed the residuals between the estimated PACL value on the virtual sensor, and the observed PACL on the field for this sensor. We did so for `r length(lads_method1)` values of LAD from `r min(lads_method1)` to `r max(lads_method1)`. By doing so, we could find for each sensor the LAD that minimizes the residuals.


```{r}
tar_load(output_lad_method1)

output_lad_method1 <- output_lad_method1 %>% 
  dplyr::group_by(site) %>% 
  dplyr::mutate(
    site_lad = mean(best_lad[converged]),
    site_label = paste0(site, " - ", 
                        round(site_lad, 3), " - ",
                        sum(converged), "/", n())
  )

n_facets <- 9
n_plt <- length(unique(output_lad_method1$site)) %/% n_facets

for (i in 1:n_plt) {
  
  tmp_plt <- output_lad_method1 %>% 
    dplyr::filter(site %in% unique(output_lad_method1$site)[1:9*i]) %>% 
    
    ggplot(aes(y = best_lad, x = id_sensor, color = converged)) +
    facet_wrap(~site_label, scales = "free_x") +
    geom_point() +
    scale_color_manual(values = c("salmon", "forestgreen")) +
    theme_bw() +
    xlab("Id of the sensor") +
    ylab("Optimised LAD")
  
  print(tmp_plt)
}
```

Many sensors did not converged (i.e. best fitting LAD was 5 as the residuals function showed an asymptotic form). Indeed, we could increase as much as we want the trees's LAD, the estimated PACL could not decrease as much as the observed one. PACL is principally linked to the crown geometries, and secondary by the crown LAD. Thus, there are two cases where crown LAD did not influence PACL: (i) for open stands, where the high light on the ground comes principally from unobstructed rays, (ii) for highly crowded stands, where the very low light on the ground comes from the high number of intercepted crowns. Another reason could be linked to the wrong representation of leaves and crown above the sensor, where a simple branch can obstruct the sensor in the field where we considered a simple crown shape that result in incapabilities of representing such a light obstruction with the SamsaraLight model. Consequently, we remove the sensors that did not converged (465/1121 sensors), leading to remove consequently 3 sites where all sensors did not converged: Cloture11, Cloture15, Cloture2.

```{r}
# Fit logistic regression model

## Fit different models
model_linear <- glm(converged ~ punobs_horizontal + PACLobs, 
                    data = output_lad_method1, 
                    family = binomial)

model_poly <- glm(converged ~ poly(punobs_horizontal, 2) + poly(PACLobs, 2) + I(punobs_horizontal*PACLobs),
                  data = output_lad_method1, 
                  family = binomial)

model_svm <- e1071::svm(as.factor(converged) ~ punobs_horizontal + PACLobs, 
                        data = output_lad_method1, 
                        kernel = "radial", cost = 1, gamma = 0.1)

model_gam <- mgcv::gam(converged ~ s(punobs_horizontal, PACLobs), 
                       data = output_lad_method1, family = binomial)


## Create a grid to draw the decision boundary
xrange <- range(output_lad_method1$PACLobs)
yrange <- range(output_lad_method1$punobs_horizontal)
grid <- expand.grid(
  PACLobs = seq(xrange[1], xrange[2], length.out = 200),
  punobs_horizontal = seq(yrange[1], yrange[2], length.out = 200)
)

## Predict probabilities
# grid$prob <- predict(model_poly, newdata = grid, type = "response")
grid$pred <- predict(model_svm, newdata = grid)

## Plot the converged sensors all site confounded ----
ggplot(data = output_lad_method1,
                  mapping = aes(y = punobs_horizontal * 100, x = PACLobs * 100,
                                color = converged)) +
  geom_point() +
  scale_color_manual(values = c("salmon", "forestgreen")) +
  # stat_contour(data = grid, mapping = aes(z = prob),
  #              breaks = 0.5, color = "black", linewidth = 1) +
  geom_contour(data = grid, mapping = aes(z = as.numeric(pred)),
               breaks = 1.5, color = "black", linewidth = 1) +
  xlab("Observed total PACL (%)") +
  ylab("Part of total PACL unobstructed (%)") +
  labs(color = "Convergence",
       title = "Relationships between site-specific LAD convergence and PACL characteristics of a sensor",
       subtitle = paste0(sum(output_lad_method1$converged), 
                         "/", nrow(output_lad_method1), " sensors converged",
                         " (i.e. ", round(sum(output_lad_method1$converged) / nrow(output_lad_method1) * 100, 0), "%)")) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, size = 12),
        plot.subtitle = element_text(hjust = 0.5),
        legend.position = "top")
```


The mean LAD over all sensors that converged was about `r round(mean(output_lad_method1$best_lad[output_lad_method1$converged]), 3)`


# A simple Bayesian approach

A first Bayesian approach would be to also fit a mean LAD value on the sensors that converged with the previous method, by considering a hierarchical random effect (site into origin, mandatory according to the structure our our dataset).

The model can be written as:
$LAD_{p} = a_{0} + a_{0,p} + \epsilon$, where $a_{0}$ is the LAD intercept and $a_{0,p}$ is a random hierarchical site effect, nested within an origin effect (4 origins of the plots within UCLouvain, INRAe, Cloture and IRRES).


```{r}
tar_load(models_setup)
tar_load(models_output)
```

```{r}
models_setup$exp_design
```

```{r}
out <- models_output[[1]]

setup <- models_setup$setups[[1]]
n_species <- setup$n_species
n_sites <- setup$n_sites
n_origins <- setup$n_origins
```

We ran 50,000 samplings for each of the 3 chains. We analyse the output by keeping the last 6,500 samplings of each chain.

The total computation time was about:

```{r}
print(out$computation_time)
```


## Intercept effect

```{r}
intercept_samples <- out$outputs %>%
  purrr::map(
    ~getSample(.x, start = 10000, end = NULL, thin = 5,
               whichParameters = which(colnames(
                 out$outputs[[1]]$chain[[1]]) == "intercept"),
               coda = TRUE) %>%
      purrr::map(~as.data.frame(.x) %>%
                   dplyr::mutate(iteration = row_number()) %>%
                   dplyr::relocate(iteration)) %>%
      dplyr::bind_rows(.id = "subchain") %>%
      tidyr::pivot_longer(cols = !c(subchain, iteration),
                          names_to = "param", values_to = "estimate")
  ) %>%
  dplyr::bind_rows(.id = "chain")
```

### Trace

```{r}
intercept_samples %>%

  ggplot(aes(y = estimate, x = iteration,
             color = chain, linetype = subchain)) +
  geom_line() +
  theme_bw()
```

### Density

```{r}
summaries_intercept <- intercept_samples %>% 
  dplyr::summarise(
    lower = quantile(estimate, probs = 0.025),
    median = quantile(estimate, probs = 0.5),
    upper = quantile(estimate, probs = 0.975)
  ) %>%
  dplyr::arrange(median) %>%
  as.data.frame()

summaries_intercept

intercept_samples %>%

  ggplot(aes(x = estimate)) +
  geom_density() +
  theme_bw() +
  geom_vline(data = summaries_intercept, aes(xintercept = lower),
             linewidth = 1.05, color = "salmon", linetype = "dotted") +
  geom_vline(data = summaries_intercept, aes(xintercept = median),
             linewidth = 1.05, color = "salmon") +
  geom_vline(data = summaries_intercept, aes(xintercept = upper),
             linewidth = 1.05, color = "salmon", linetype = "dotted") +
  geom_vline(xintercept = 0, linetype = "dashed")
```



<!-- ## Species effect -->

<!-- ```{r} -->

<!-- species_sample <- out$outputs %>%  -->

<!--   purrr::map( -->

<!--     ~getSample(.x, start = 10000, end = NULL, thin = 1, -->

<!--                whichParameters = (1:n_species) + 3 + n_sites + n_origins, -->

<!--                coda = TRUE) %>% -->

<!--       purrr::map(~as.data.frame(.x) %>%  -->

<!--                    dplyr::mutate(iteration = row_number()) %>%  -->

<!--                    dplyr::relocate(iteration)) %>% -->

<!--       dplyr::bind_rows(.id = "subchain") %>%  -->

<!--       tidyr::pivot_longer(cols = !c(subchain, iteration), -->

<!--                           names_to = "species", values_to = "estimate", -->

<!--                           names_prefix = "species.") -->

<!--   ) %>%  -->

<!--   dplyr::bind_rows(.id = "chain") -->

<!-- ``` -->

<!-- ### Trace -->

<!-- ```{r} -->

<!-- species_sample %>%  -->

<!--   ggplot(aes(y = estimate, x = iteration,  -->

<!--              color = chain, linetype = subchain)) + -->

<!--   geom_line() + -->

<!--   facet_wrap(~species) + -->

<!--   theme_bw() -->

<!-- ``` -->

<!-- ### Density -->

<!-- ```{r} -->

<!-- summaries_sp <- species_sample %>% -->

<!--   dplyr::group_by(species) %>% -->

<!--   dplyr::summarise( -->

<!--     lower = quantile(estimate, probs = 0.025), -->

<!--     median = quantile(estimate, probs = 0.5), -->

<!--     upper = quantile(estimate, probs = 0.975) -->

<!--   ) %>% -->

<!--   dplyr::arrange(median) %>% -->

<!--   as.data.frame() -->

<!-- summaries_sp -->

<!-- species_sample %>% -->

<!--   ggplot(aes(x = estimate)) + -->

<!--   geom_density() + -->

<!--   facet_wrap(~species, scales = "free_y") + -->

<!--   theme_bw() + -->

<!--   geom_vline(data = summaries_sp, aes(xintercept = lower), -->

<!--              linewidth = 1.05, color = "salmon", linetype = "dotted") + -->

<!--   geom_vline(data = summaries_sp, aes(xintercept = median), -->

<!--              linewidth = 1.05, color = "salmon") + -->

<!--   geom_vline(data = summaries_sp, aes(xintercept = upper), -->

<!--              linewidth = 1.05, color = "salmon", linetype = "dotted") -->

<!-- ``` -->

<!-- ## DBH effect -->

<!-- ```{r} -->

<!-- dbh_samples <- out$outputs %>%  -->

<!--   purrr::map( -->

<!--     ~getSample(.x, start = 10000, end = NULL, thin = 1, -->

<!--                whichParameters = (1:n_species) + 3 + n_sites + n_origins + n_species, -->

<!--                coda = TRUE) %>% -->

<!--       purrr::map(~as.data.frame(.x) %>%  -->

<!--                    dplyr::mutate(iteration = row_number()) %>%  -->

<!--                    dplyr::relocate(iteration)) %>% -->

<!--       dplyr::bind_rows(.id = "subchain") %>%  -->

<!--       tidyr::pivot_longer(cols = !c(subchain, iteration), -->

<!--                           names_to = "species", values_to = "estimate", -->

<!--                           names_prefix = "species.") -->

<!--   ) %>%  -->

<!--   dplyr::bind_rows(.id = "chain") -->

<!-- ``` -->

<!-- ### Trace -->

<!-- ```{r} -->

<!-- dbh_samples %>%  -->

<!--   ggplot(aes(y = estimate, x = iteration,  -->

<!--              color = chain, linetype = subchain)) + -->

<!--   geom_line() + -->

<!--   facet_wrap(~species) + -->

<!--   theme_bw() -->

<!-- ``` -->

<!-- ### Density -->

<!-- ```{r} -->

<!-- summaries_dbh <- dbh_samples %>% -->

<!--   dplyr::group_by(species) %>% -->

<!--   dplyr::summarise( -->

<!--     lower = quantile(estimate, probs = 0.025), -->

<!--     median = quantile(estimate, probs = 0.5), -->

<!--     upper = quantile(estimate, probs = 0.975) -->

<!--   ) %>% -->

<!--   dplyr::arrange(median) %>% -->

<!--   as.data.frame() -->

<!-- dbh_samples %>% -->

<!--   ggplot(aes(x = estimate)) + -->

<!--   geom_density() + -->

<!--   facet_wrap(~species, scales = "free_y") + -->

<!--   theme_bw() + -->

<!--   geom_vline(data = summaries_dbh, aes(xintercept = lower), -->

<!--              linewidth = 1.05, color = "salmon", linetype = "dotted") + -->

<!--   geom_vline(data = summaries_dbh, aes(xintercept = median), -->

<!--              linewidth = 1.05, color = "salmon") + -->

<!--   geom_vline(data = summaries_dbh, aes(xintercept = upper), -->

<!--              linewidth = 1.05, color = "salmon", linetype = "dotted") + -->

<!--   geom_vline(xintercept = 0, linetype = "dashed") -->

<!-- ``` -->

<!-- ## Competition effect -->

<!-- The competition effect is the BAHT (basal area of higher trees, in $m^2.ha{-1}$), i.e. similar to BAL but considering the higher trees, not the larger ones). -->

<!-- ```{r} -->

<!-- compet_samples <-  out$outputs %>%  -->

<!--   purrr::map( -->

<!--     ~getSample(.x, start = 10000, end = NULL, thin = 1, -->

<!--                whichParameters = (1:n_species) + 3 + n_sites + n_origins + 2*n_species, -->

<!--                coda = TRUE) %>% -->

<!--       purrr::map(~as.data.frame(.x) %>%  -->

<!--                    dplyr::mutate(iteration = row_number()) %>%  -->

<!--                    dplyr::relocate(iteration)) %>% -->

<!--       dplyr::bind_rows(.id = "subchain") %>%  -->

<!--       tidyr::pivot_longer(cols = !c(subchain, iteration), -->

<!--                           names_to = "species", values_to = "estimate", -->

<!--                           names_prefix = "species.") -->

<!--   ) %>%  -->

<!--   dplyr::bind_rows(.id = "chain") -->

<!-- ``` -->

<!-- ### Trace -->

<!-- ```{r} -->

<!-- compet_samples %>%  -->

<!--   ggplot(aes(y = estimate, x = iteration,  -->

<!--              color = chain, linetype = subchain)) + -->

<!--   geom_line() + -->

<!--   facet_wrap(~species) + -->

<!--   theme_bw() -->

<!-- ``` -->

<!-- ### Density -->

<!-- ```{r} -->

<!-- summaries_compet <- compet_samples %>% -->

<!--   dplyr::group_by(species) %>% -->

<!--   dplyr::summarise( -->

<!--     lower = quantile(estimate, probs = 0.025), -->

<!--     median = quantile(estimate, probs = 0.5), -->

<!--     upper = quantile(estimate, probs = 0.975) -->

<!--   ) %>% -->

<!--   dplyr::arrange(median) %>% -->

<!--   as.data.frame() -->

<!-- compet_samples %>% -->

<!--   ggplot(aes(x = estimate)) + -->

<!--   geom_density() + -->

<!--   facet_wrap(~species, scales = "free_y") + -->

<!--   theme_bw() + -->

<!--   geom_vline(data = summaries_compet, aes(xintercept = lower), -->

<!--              linewidth = 1.05, color = "salmon", linetype = "dotted") + -->

<!--   geom_vline(data = summaries_compet, aes(xintercept = median), -->

<!--              linewidth = 1.05, color = "salmon") + -->

<!--   geom_vline(data = summaries_compet, aes(xintercept = upper), -->

<!--              linewidth = 1.05, color = "salmon", linetype = "dotted") + -->

<!--   geom_vline(xintercept = 0, linetype = "dashed") -->

<!-- ``` -->



## Site and origin effects

```{r}
random_samples <- out$outputs %>%
  purrr::map(
    ~getSample(.x, start = 8000, end = NULL, thin = 1,
               whichParameters = 1:(n_sites+n_origins) + 3,
               coda = TRUE) %>%
      purrr::map(~as.data.frame(.x) %>%
                   dplyr::mutate(iteration = row_number()) %>%
                   dplyr::relocate(iteration)) %>%
      dplyr::bind_rows(.id = "subchain") %>%
      tidyr::pivot_longer(cols = !c(subchain, iteration),
                          names_to = "param", values_to = "estimate") %>%
      tidyr::separate(param, c("param", "modality"), sep = "\\.")
  ) %>%
  dplyr::bind_rows(.id = "chain")
```

### Trace - origins

```{r}
random_samples %>%
  dplyr::filter(param == "origin") %>%

  ggplot(aes(y = estimate, x = iteration,
             color = chain, linetype = subchain)) +
  geom_line() +
  facet_wrap(~modality) +
  theme_bw()
```

### Density - origins

```{r}
summaries_origins <- random_samples %>%
  dplyr::filter(param == "origin") %>%
  dplyr::group_by(modality) %>%
  dplyr::summarise(
    lower = quantile(estimate, probs = 0.025),
    median = quantile(estimate, probs = 0.5),
    upper = quantile(estimate, probs = 0.975)
  ) %>%
  dplyr::arrange(median) %>%
  as.data.frame()

random_samples %>%
  dplyr::filter(param == "origin") %>%

  ggplot(aes(x = estimate)) +
  geom_density() +
  facet_wrap(~modality, scales = "free_y") +
  theme_bw() +
  geom_vline(data = summaries_origins, aes(xintercept = lower),
             linewidth = 1.05, color = "salmon", linetype = "dotted") +
  geom_vline(data = summaries_origins, aes(xintercept = median),
             linewidth = 1.05, color = "salmon") +
  geom_vline(data = summaries_origins, aes(xintercept = upper),
             linewidth = 1.05, color = "salmon", linetype = "dotted") +
  geom_vline(xintercept = 0, linetype = "dashed")
```

### Trace - sites

```{r}
random_samples %>%
  dplyr::filter(grepl("Cloture", modality)) %>%

  ggplot(aes(y = estimate, x = iteration,
             color = chain, linetype = subchain)) +
  geom_line() +
  facet_wrap(~modality) +
  theme_bw() +
  theme(strip.text.x = element_text(
    size = 6,
    margin = margin(0,0,0,0, "cm")))
```

```{r}
random_samples %>%
  dplyr::filter(!grepl("Cloture", modality)) %>%

  ggplot(aes(y = estimate, x = iteration,
             color = chain, linetype = subchain)) +
  geom_line() +
  facet_wrap(~modality) +
  theme_bw() +
  theme(strip.text.x = element_text(
    size = 6,
    margin = margin(0,0,0,0, "cm")))
```

### Density - sites

```{r}
summaries_sitesCloture <- random_samples %>%
  dplyr::filter(grepl("Cloture", modality)) %>%

  dplyr::group_by(modality) %>%
  dplyr::summarise(
    lower = quantile(estimate, probs = 0.025),
    median = quantile(estimate, probs = 0.5),
    upper = quantile(estimate, probs = 0.975)
  ) %>%
  dplyr::arrange(median) %>%
  as.data.frame()

random_samples %>%
  dplyr::filter(grepl("Cloture", modality)) %>%

  ggplot(aes(x = estimate)) +
  geom_density() +
  facet_wrap(~modality, scales = "free_y") +
  theme_bw() +
  theme(strip.text.x = element_text(
    size = 6,
    margin = margin(0,0,0,0, "cm"))) +
  geom_vline(data = summaries_sitesCloture, aes(xintercept = lower),
             linewidth = 1.05, color = "salmon", linetype = "dotted") +
  geom_vline(data = summaries_sitesCloture, aes(xintercept = median),
             linewidth = 1.05, color = "salmon") +
  geom_vline(data = summaries_sitesCloture, aes(xintercept = upper),
             linewidth = 1.05, color = "salmon", linetype = "dotted") +
  geom_vline(xintercept = 0, linetype = "dashed")
```

```{r}
summaries_sitesOther <- random_samples %>%
  dplyr::filter(!grepl("Cloture", modality)) %>%

  dplyr::group_by(modality) %>%
  dplyr::summarise(
    lower = quantile(estimate, probs = 0.025),
    median = quantile(estimate, probs = 0.5),
    upper = quantile(estimate, probs = 0.975)
  ) %>%
  dplyr::arrange(median) %>%
  as.data.frame()

random_samples %>%
  dplyr::filter(!grepl("Cloture", modality)) %>%

  ggplot(aes(x = estimate)) +
  geom_density() +
  facet_wrap(~modality, scales = "free_y") +
  theme_bw() +
  theme(strip.text.x = element_text(
    size = 6,
    margin = margin(0,0,0,0, "cm"))) +
  geom_vline(data = summaries_sitesOther, aes(xintercept = lower),
             linewidth = 1.05, color = "salmon", linetype = "dotted") +
  geom_vline(data = summaries_sitesOther, aes(xintercept = median),
             linewidth = 1.05, color = "salmon") +
  geom_vline(data = summaries_sitesOther, aes(xintercept = upper),
             linewidth = 1.05, color = "salmon", linetype = "dotted") +
  geom_vline(xintercept = 0, linetype = "dashed")
```

<!-- ## Residuals -->

<!-- ```{r} -->

<!-- tar_load(models_summary_pointwise) -->

<!-- ``` -->

<!-- ```{r} -->

<!-- models_summary_pointwise[[1]]$residuals %>%  -->

<!--   as.data.frame() %>%  -->

<!--   tidyr::pivot_longer(everything(), -->

<!--                       names_to = "obs", -->

<!--                       values_to = "res") %>%  -->

<!--   dplyr::mutate(obs = as.numeric(gsub("V", "", obs))) %>%  -->

<!--   ggplot(aes(x = res)) + -->

<!--   geom_density() + -->

<!--   theme_bw() -->

<!-- ``` -->

<!-- ## Predictions -->

<!-- ```{r} -->

<!-- pred_samples <-  out$outputs %>%  -->

<!--   purrr::map( -->

<!--     ~getSample(.x, start = 10000, end = NULL, thin = 1, -->

<!--                whichParameters = (1:(n_species*3)) + 3 + n_sites + n_origins, -->

<!--                coda = TRUE) %>% -->

<!--       purrr::map(~as.data.frame(.x) %>%  -->

<!--                    dplyr::mutate(iteration = row_number()) %>%  -->

<!--                    dplyr::relocate(iteration)) %>% -->

<!--       dplyr::bind_rows(.id = "subchain") %>%  -->

<!--       tidyr::pivot_longer(cols = !c(subchain, iteration), -->

<!--                           names_pattern = "(.*)\\.(.*)", -->

<!--                           names_to = c("param", "species"),  -->

<!--                           values_to = "estimate") -->

<!--   ) %>%  -->

<!--   dplyr::bind_rows(.id = "chain") -->

<!-- preds <- expand.grid( -->

<!--   species = unique(pred_samples$species), -->

<!--   dbh_cm = 10: -->

<!-- ) -->

<!-- ``` -->

<!-- # Going further with the Bayesian approach -->

<!-- # Limits -->

<!-- **There is still problem of convergence,** we need to explore why. Intercept and slope can compensate for each other (e.g., high intercept with negative slope vs low intercept with positive slope), the model may not be fully identifiable with the current data: Standardize predictors (like dbh and BALh) to reduce correlation with the intercept, consider covariance between slopes and intercept or constrain parameters using more informative priors (e.g. high or low LAD ?) -->

<!-- **We may miss some important environmental factors in this study.** One hypothesis is that LAD could be highly dependent on variables that we do not consider, such as the tree sanitary health or the site water availability. Here, it may not be possible to consider a climatic effect, because the intra-origin variability in climate may not be sufficient (for example, the 24 Cloture sites are located in the same area). The effect of climate may be contained within the origin random effect, that may also account for other environmental constraints and the protocol effect. -->

<!-- **We could imagine** **another index of competition such as dbh/dg**, which represents more a relative index of competition (i.e. a status within the stand), rather than an absolute index such as BALh. Moreover, the effects are linear, but we could imagine transformations to model for example a plateau effect for competition ? -->


<!-- # Perspectives -->

<!-- Once we are satisfied with the modelling approach, we will study the ecological mechanisms that could underlie the differences between species. Do species with different shade tolerance have different leaf area densities? Do they react differently to competition? **Ecological assumptions still have to be made.** -->
