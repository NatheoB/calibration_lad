---
title: "LAD calibration"
output: 
  html_document:
    toc: true
date: "2025-09-24"
author: "Nath√©o BEAUCHAMP"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)
```

```{r}
library(targets)
library(dplyr)
library(tidyr)

library(ggplot2)
library(cowplot)
library(ggforce)
library(legendry)
library(grid)
library(gridExtra)

library(BayesianTools)
library(coda)
```

# Motivation of the study

This study aims to calibrate Leaf Area Density (LAD), which is defined as the area of leaves per unit of tree crown volume (in $m^2.m^{-3}$). This parameter forms the basis of numerous process-based forest models, such as physiological models that consider photosynthesis and transpiration (e.g. SurEau by Cochard et al., 2021), and forest gap models that estimate light interception (e.g. ForCEEPS by Morin et al., 2021, and Samsara2 by Courbaud et al., 2015).

Although the leaf area density can be directly estimated from a sample of trees (Stadt & Lieffers, 2000), this method is laborious and difficult to replicate for every tree in a stand. Therefore, indirect methods can be employed, such as model inversion using a hemispherical photograph (Courbaud et al., 2003) or the more recent LiDAR methodology (Wei et al., 2020). However, there is a significant lack of research on LAD in the scientific literature, as there are no large-scale databases containing values for a wide range of European species. Furthermore, the few reported species-specific values vary considerably between studies (Ligot et al., 2014).

The aim of this study is to estimate leaf area density (LAD) for nine different species/groups: Fagus sylvatica, Picea abies, Quercus sp., Carpinus betulus, Pseudotsuga menziesii, Pinus sylvestris, Abies alba, Larix decidua and 'other species'. Additionally, Nock et al. (2008) demonstrated intraspecific variation in LAD, with intracrown leaf area decreasing by up to 40% with increasing tree age. This led us to consider the effect of diameter as well. Finally, as crown dimensions are very sensitive to local competition (Touzot et al., 2025), we hypothesise that LAD may also vary in response to competition.

# Methodology

In this study, we used a model inversion methodology, using the ray-tracing model SamsaraLight (Courbaud et al. 2003). We want to estimate the SamsaraLight tree-level parameter LAD using measurements of transmitted light $PACL_{obs}$ (for percentage of above light canopy), based on hemispherical photographs, within 45 plots of different composition and structures. For each plot, trees are inventoried with their crown dimensions, allowing to derive an estimated transmitted light $PACL_{est}$ on virtual sensors with the ray-tracing model SamsaraLight. By doing so, for each virtual sensor of each plot, we have the observed transmitted light $PACL_{obs}$, and the estimated transmitted light given a tree-level value of LAD $PACL_{est}$.

The aim of the calibration is to find a tree-level LAD model that minimize the error between $PACL_{obs}$ and $PACL_{est}$. To do so, we defined the LAD for a tree $i$, of species $s$ in a plot $p$ as $LAD_{i,s,p} = a_{0,s} + a_{0,p} + a_{1,s}.DBH_i + a_{2,s}.BAH_i + \epsilon$, where $a_{0,s}$ is a species-specific intercept, $a_{0,p}$ is a random hierarchical site effect, nested within an origin effect (4 origins of the plots within UCLouvain, INRAe, Cloture and IRRES), $DBH_i$ is the diameter at breast height of tree $i$ , with the associated estimated species-specific coefficient $a_{1,s}$, $BAH_i$ the competition index of the tree $i$ (*i.e.* the sum of basal area of trees higher than the tree $i$), with the associated estimated species-specific coefficient $a_{2,s}$, and $\epsilon$ the normal error term. We used a Bayesian approach to estimate the posterior distribution of parameters that minimize the log-likelihood between observed and simulated PACL. As computation of $PACL_{est}$ needs an external call of SamsaraLight model, we used the R package 'BayesianTools' to run a MCMC sampling of parameters with the "DREAMzs" sampling algorithm.

For this study, we used the SamsaraLight model with the R package SamsaraLight (Beauchamp et al., work in progress, intended for publication in the Journal of Open Source Software). The SamsaraLight model was initially developed in Java and included in the Capsis simulation platform (SamsaraLightLoader by Gauthier Ligot). It could be called from R software via the "RCapsis" R package (Fortin et al., 2021). To speed up calculation times and make SamsaraLight easier to use in an R environment, we created the "SamsaraLight" R package. The source code is written in C++ to enable fast calculations and communication with the R environment is handled by the Rcpp package (Eddelbuettel & Balamuta, 2018). The "SamsaRaLight" R package reduces calculation time compared to the previous method (the RCapsis R package calling the Java model SamsaRaLightLoader) as it does not require the creation of a Java server nor Java objects. It also facilitates the use of SamsaraLight within R, as it does not require the creation of an inventory file, instead using R objects and functions directly. The package is functional and stored in a GitHub repository, but it is still subject to private restrictions as discussions regarding co-authorship and the intellectual property rights of the source code need to be concluded.

# Calibration plots

The 45 calibration plots comes from 4 different sources we wiil call IRRES (9 plots, Gauthier Ligot), CLOTURE (23 plots, Gauthier Ligot), INRAe (10 plots, Philippe Balandier) and UCLouvain (3 plots, Mathieu Jonard).

```{r}
plot_stand <- function(init_db, site, cell_size) {
  
  # Get trees inventory
  tmp_data_trees <- init_db$trees[[site]] %>% 
    dplyr::left_join(init_db$species[[site]], 
                     by = c("SpCode" = "SpCode_SamsaraLL")) %>% 
    dplyr::mutate(crown_type = "8E") %>% 
    dplyr::select(id_tree = Id, 
                  species_code = SpCode,
                  species_calib = sp_calib,
                  x = X, y = Y, dbh_cm = Dbh,
                  crown_type, h_m = H, hbase_m = CBH, hmax_m = CMRH,
                  rn_m = RN, rs_m = RS, re_m = RE, rw_m = RW,
                  crown_openess = CrownOpenness, crown_lad = LAD)
  
  
  # If the plot extent dataframe is empty, set it to the default one
  tmp_plot_extent <- init_db$plot_extents[[site]]
  
  if (!is.null(tmp_plot_extent)) {
    tmp_plot_extent <- tmp_plot_extent %>% 
      dplyr::select(x = X, y = Y)
  }
  
  use_rect_zone <- ifelse(is.null(tmp_plot_extent), TRUE, FALSE)
  
  
  # Create a square plot with the inventory in the center
  tmp_stand <- SamsaRaLight::create_rect_stand(tmp_data_trees, 
                                               cell_size, 
                                               tmp_plot_extent,
                                               use_rect_zone,
                                               fill_around = FALSE)
  
  
  # Add sensors and shift coordinates inside the rect stand
  tmp_stand$sensors <- init_db$sensors[[site]] %>% 
    dplyr::select(id_sensor = id, x, y, h_m = z) %>% 
    dplyr::mutate(
      x = x + tmp_stand$info$shift_x,
      y = y + tmp_stand$info$shift_y
    )
  
  # Add species information to the tree dataset
  data_plot <- init_db$plots %>% dplyr::filter(name == site)
  data_species <- init_db$species[[site]]
  
  data_trees <- tmp_stand$trees %>% 
    dplyr::left_join(data_species,
                     by = c("species_code" = "SpCode_SamsaraLL")) %>% 
    dplyr::mutate(Essence_Latin = factor(Essence_Latin, levels = data_species$Essence_Latin))
  
  
  ## Create cell dataframe
  cells_xcenter <- seq(tmp_stand$info$cell_size / 2, 
                       tmp_stand$info$cell_size * tmp_stand$info$n_cells_x - tmp_stand$info$cell_size / 2,
                       by = tmp_stand$info$cell_size)
  
  cells_ycenter <- seq(tmp_stand$info$cell_size / 2, 
                       tmp_stand$info$cell_size * tmp_stand$info$n_cells_y - tmp_stand$info$cell_size / 2,
                       by = tmp_stand$info$cell_size)
  
  data_cells <- expand.grid(
    x_center = cells_xcenter,
    y_center = cells_ycenter
  )
  
  
  # Create the plot
  stand_plot <- ggplot() +
    coord_equal() +
    
    # CELLS 
    geom_tile(data = data_cells, 
              mapping = aes(x = x_center, y = y_center), 
              fill = "white", color = "darkgray")
  
  
  # CORE POLYGON
  if (!is.null(tmp_stand$inv_zone_df)) {  
    stand_plot <- stand_plot +
      geom_polygon(data = tmp_stand$inv_zone_df,
                   mapping = aes(x = x, y = y),
                   fill = "yellow", color = "black", alpha = 0.5)
  }
  
  
  # TREES
  stand_plot <- stand_plot +
    geom_ellipse(data = data_trees, 
                 mapping = aes(x0 = x, y0 = y, 
                               a = (re_m + rw_m) / 2,
                               b = (rn_m + rs_m) / 2,
                               angle = 0,
                               fill = Essence_Latin)) +
    scale_fill_manual(values = data_species$Couleur) +
    labs(fill = "Species") +
    
    # SENSORS
    geom_rect(data = tmp_stand$sensors,
              mapping = aes(xmin = x - 0.5,
                            ymin = y - 0.5,
                            xmax = x + 0.5,
                            ymax = y + 0.5),
              color = "red", fill = "black") +
    
    # GRAPHIC
    scale_x_continuous(breaks = seq(0, tmp_stand$info$n_cells_x * tmp_stand$info$cell_size,
                                    by = tmp_stand$info$cell_size),
                       labels = round(seq(0, tmp_stand$info$n_cells_x * tmp_stand$info$cell_size,
                                          by = tmp_stand$info$cell_size),
                                      digits = 1)) +
    scale_y_continuous(breaks = seq(0, tmp_stand$info$n_cells_y * tmp_stand$info$cell_size,
                                    by = tmp_stand$info$cell_size),
                       labels = round(seq(0, tmp_stand$info$n_cells_y * tmp_stand$info$cell_size,
                                          by = tmp_stand$info$cell_size),
                                      digits = 1)) +
    xlab("") + ylab("") +
    
    labs(title = site,
         subtitle = paste0(round(tmp_stand$info$core_area_ha, 2), "ha - ",
                           round(tmp_stand$info$core_batot_m2ha, 2), "m2/ha - ",
                           nrow(tmp_stand$trees), "trees",
                           "\n",
                           "(long ", round(data_plot$longitude, 2), ", lat ", 
                           round(data_plot$latitude, 2), ") - ",
                           "slope = ", round(data_plot$slope, 1), 
                           ", aspect = ", round(data_plot$aspect),
                           ", northToX = ", round(data_plot$northToX))) +
    
    theme_minimal() +
    theme(panel.grid.minor = element_blank(),
          legend.position = "right",
          plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5)) 
  
  # Print plot
  plot(stand_plot)
}
```

```{r}
# Get data
tar_load(init_db)

# Set the cell size, which will not impact the study as we compute light only on sensors
cell_size <- 10

# Sites names
site_names <- init_db$plots$name
```

## IRRES

```{r}
for (site in site_names[grepl("IRRES", site_names)]) {
  plot_stand(init_db, site, cell_size)
}
```

## CLOTURE

```{r}
for (site in site_names[grepl("Cloture", site_names)]) {
  plot_stand(init_db, site, cell_size)
}
```

## INRAe

```{r}
for (site in site_names[unique(c(grep("Ventoux", site_names), grep("Lorris", site_names),  grep("Fontfreyde", site_names)))]) {
  plot_stand(init_db, site, cell_size)
}
```

## UCLouvain

```{r}
for (site in site_names[grepl("Baileux", site_names)]) {
  plot_stand(init_db, site, cell_size)
}
```


# Preliminary analysis

```{r}
tar_load(lads_method1)
```

As a preliminary analysis, we tried to fit a mean LAD value for each sensor of each site. To do so, we run the SamsaraLight model on each stand by fixing the same crown LAD values of each tree, and for each sensor, we computed the residuals between the estimated PACL value on the virtual sensor, and the observed PACL on the field for this sensor. We did so for `r length(lads_method1)` values of LAD from `r min(lads_method1)` to `r max(lads_method1)`. By doing so, we could find for each sensor the LAD that minimizes the residuals.


```{r}
tar_load(output_lad_method1)
tar_load(lad_convergence_threshold)

output_lad_method1 <- output_lad_method1 %>% 
  dplyr::group_by(site) %>% 
  dplyr::mutate(
    site_lad = mean(best_lad[converged]),
    site_label = paste0(site, " - ", 
                        round(site_lad, 3), " - ",
                        sum(converged), "/", n())
  )

n_facets <- 9
n_plt <- length(unique(output_lad_method1$site)) %/% n_facets

for (i in 1:n_plt) {
  
  tmp_plt <- output_lad_method1 %>% 
    dplyr::filter(site %in% unique(output_lad_method1$site)[(1:9) + (i-1)*9]) %>% 
    
    ggplot(aes(y = best_lad, x = id_sensor, color = converged)) +
    facet_wrap(~site_label, scales = "free_x") +
    geom_point() +
    geom_hline(yintercept = lad_convergence_threshold,
               linetype = "dashed") +
    scale_color_manual(values = c("salmon", "forestgreen")) +
    theme_bw() +
    xlab("Id of the sensor") +
    ylab("Optimised LAD")
  
  print(tmp_plt)
}
```

Many sensors did not converged (i.e. best fitting LAD was 5 as the residuals function showed an asymptotic form). Indeed, we could increase as much as we want the trees's LAD, the estimated PACL could not decrease as much as the observed one. PACL is principally linked to the crown geometries, and secondary by the crown LAD. Thus, there are two cases where crown LAD did not influence PACL: (i) for open stands, where the high light on the ground comes principally from unobstructed rays, (ii) for highly crowded stands, where the very low light on the ground comes from the high number of intercepted crowns. Another reason could be linked to the wrong representation of leaves and crown above the sensor, where a simple branch can obstruct the sensor in the field where we considered a simple crown shape that result in incapabilities of representing such a light obstruction with the SamsaraLight model. Consequently, we remove the sensors that did not converged (465/1121 sensors), leading to remove consequently 3 sites where all sensors did not converged: Cloture11, Cloture15, Cloture2.

```{r}
# Fit logistic regression model

## Fit different models
model_linear <- glm(converged ~ punobs + pacl_obs, 
                    data = output_lad_method1, 
                    family = binomial)

model_poly <- glm(converged ~ poly(punobs, 2) + poly(pacl_obs, 2) + I(punobs*pacl_obs),
                  data = output_lad_method1, 
                  family = binomial)

model_svm <- e1071::svm(as.factor(converged) ~ punobs + pacl_obs, 
                        data = output_lad_method1, 
                        kernel = "radial", cost = 1, gamma = 0.1)

model_gam <- mgcv::gam(converged ~ s(punobs, pacl_obs), 
                       data = output_lad_method1, family = binomial)


## Create a grid to draw the decision boundary
xrange <- range(output_lad_method1$pacl_obs)
yrange <- range(output_lad_method1$punobs)
grid <- expand.grid(
  pacl_obs = seq(xrange[1], xrange[2], length.out = 200),
  punobs = seq(yrange[1], yrange[2], length.out = 200)
)

## Predict probabilities
# grid$prob <- predict(model_poly, newdata = grid, type = "response")
grid$pred <- predict(model_svm, newdata = grid)

## Plot the converged sensors all site confounded ----
ggplot(data = output_lad_method1,
                  mapping = aes(y = punobs * 100, x = pacl_obs * 100,
                                color = converged)) +
  geom_point() +
  scale_color_manual(values = c("salmon", "forestgreen")) +
  # stat_contour(data = grid, mapping = aes(z = prob),
  #              breaks = 0.5, color = "black", linewidth = 1) +
  geom_contour(data = grid, mapping = aes(z = as.numeric(pred)),
               breaks = 1.5, color = "black", linewidth = 1) +
  xlab("Observed total PACL (%)") +
  ylab("Part of total PACL unobstructed (%)") +
  labs(color = "Convergence",
       title = "Relationships between site-specific LAD convergence and PACL characteristics of a sensor",
       subtitle = paste0(sum(output_lad_method1$converged), 
                         "/", nrow(output_lad_method1), " sensors converged",
                         " (i.e. ", round(sum(output_lad_method1$converged) / nrow(output_lad_method1) * 100, 0), "%)")) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, size = 12),
        plot.subtitle = element_text(hjust = 0.5),
        legend.position = "top")
```


The mean LAD over all sensors that converged was about `r round(mean(output_lad_method1$best_lad[output_lad_method1$converged]), 3)`


# Bayesian calibration

<!-- # ```{r} -->
<!-- # load("output/calib/out_20251202_clean.Rdata") -->
<!-- # ``` -->


<!-- ## Observe the effect of sensors filtering -->

<!-- A first Bayesian approach would be to also fit a mean LAD value on the sensors that converged with the previous method, by considering a hierarchical random effect (site into origin, mandatory according to the structure our our dataset). -->

<!-- The model can be written as: -->
<!-- $LAD_{p} = a_{0} + a_{0,p} + \epsilon$, where $a_{0}$ is the LAD intercept and $a_{0,p}$ is a random hierarchical site effect, nested within an origin effect (4 origins of the plots within UCLouvain, INRAe, Cloture and IRRES). -->


<!-- ```{r} -->
<!-- mods_exp1 <- c("1_1", "1_2") -->
<!-- out_exp1 <- out_list$output[mods_exp1]   -->
<!-- ``` -->


<!-- ### Computation time -->

<!-- ```{r} -->
<!-- dplyr::left_join( -->

<!--   # Experimental design -->
<!--   out_list$exp_design %>%  -->
<!--     dplyr::filter(id_simu %in% mods_exp1), -->

<!--   # Comutation times -->
<!--   out_exp1 %>%  -->
<!--     purrr::map(~data.frame(time_hours = as.numeric(.x$computation_time,  -->
<!--                                              units = "hours"))) %>%  -->
<!--     dplyr::bind_rows(.id = "id_simu"), -->

<!--   by = "id_simu" -->
<!-- ) %>%  -->

<!--   dplyr::select(id_mod, n_chains, n_iterations,  -->
<!--                 filter_sensors,  -->
<!--                 time_hours) %>%  -->
<!--   as.data.frame() -->
<!-- ``` -->


<!-- ### Compare models and intercept predictions -->

<!-- ```{r plot_exp1} -->
<!-- # Get models evalution  outputs  -->
<!-- eval_exp1_list <- out_list$evaluation$indicators[mods_exp1]  -->

<!-- # Parameters -->
<!-- n_analysis_exp1 <- 5000 -->
<!-- thinning_exp1 <- 1 -->



<!-- # Compute mean LAD distribution -->
<!-- lad_exp1 <- out_exp1 %>%  -->
<!--   purrr::map(~.x$outputs %>%  -->
<!--                getSample(start = nrow(.x$outputs$chain[[1]]) - n_analysis_exp1,  -->
<!--                          end = NULL,  -->
<!--                          thin = thinning_exp1, -->
<!--                          coda = TRUE) %>% -->
<!--                purrr::map(~as.data.frame(.x) %>% -->
<!--                             dplyr::mutate(iteration = row_number()) %>% -->
<!--                             dplyr::relocate(iteration)) %>% -->
<!--                dplyr::bind_rows(.id = "subchain")) %>% -->
<!--   dplyr::bind_rows(.id = "id_simu") %>%  -->
<!--   dplyr::mutate( -->
<!--     sigma = exp(sigma_log), -->
<!--     lad = exp(intercept + 0.5*sigma^2) # do not forget to add variance term, as here we compute the mean of a log-normal   -->
<!--   ) %>%  -->
<!--   dplyr::left_join(out_list$exp_design, by = "id_simu") -->



<!-- # Compute LAD summaries -->
<!-- summaries_exp1 <- lad_exp1 %>%  -->
<!--   dplyr::group_by(id_simu, filter_sensors) %>%  -->
<!--   dplyr::summarise( -->
<!--     lad_qt025 = quantile(lad, 0.025), -->
<!--     lad_median = quantile(lad, 0.5), -->
<!--     lad_qt975 = quantile(lad, 0.975) -->
<!--   ) %>%  -->
<!--   dplyr::ungroup() -->

<!-- print(summaries_exp1 %>% as.data.frame()) -->



<!-- # Create plot label -->
<!-- summaries_exp1 <- summaries_exp1 %>%  -->
<!--   dplyr::mutate(mod_label = paste0(filter_sensors, " | ", round(lad_median, 3))) -->

<!-- lad_exp1 <- lad_exp1 %>%  -->
<!--   dplyr::left_join(summaries_exp1, by = "id_simu") -->

<!-- eval_exp1 <- eval_exp1_list %>% -->
<!--   dplyr::bind_rows(.id = "id_simu") %>%  -->
<!--   dplyr::left_join(summaries_exp1, by = "id_simu") -->


<!-- # Compute summaries of MAE and RMSE -->
<!-- summaries_eval_exp1 <- eval_exp1 %>%  -->
<!--   dplyr::group_by(id_simu, filter_sensors) %>%  -->
<!--   dplyr::summarise( -->

<!--     mae_qt025 = quantile(MAE, 0.025), -->
<!--     mae_median = quantile(MAE, 0.5), -->
<!--     mae_qt975 = quantile(MAE, 0.975), -->

<!--     rmse_qt025 = quantile(RMSE, 0.025), -->
<!--     rmse_median = quantile(RMSE, 0.5), -->
<!--     rmse_qt975 = quantile(RMSE, 0.975) -->

<!--   ) %>%  -->
<!--   dplyr::ungroup() -->

<!-- print(summaries_eval_exp1 %>% as.data.frame()) -->



<!-- # Plot summaries and distribution of LAD -->
<!-- plot_exp1_lad <- lad_exp1 %>%  -->

<!--   ggplot(aes(x = lad, color = mod_label)) + -->

<!--   geom_vline(data = summaries_exp1,  -->
<!--              aes(xintercept = lad_qt025, color = mod_label), -->
<!--              linewidth = 0.9, linetype = "dotted", alpha = 0.7) + -->
<!--   geom_vline(data = summaries_exp1,  -->
<!--              aes(xintercept = lad_median, color = mod_label), -->
<!--              linewidth = 0.9, linetype = "dashed", alpha = 0.7) + -->
<!--   geom_vline(data = summaries_exp1,  -->
<!--              aes(xintercept = lad_qt975, color = mod_label), -->
<!--              linewidth = 0.9, linetype = "dotted", alpha = 0.7) + -->

<!--   geom_density(linewidth = 0.5) + -->

<!--   xlab("Intercept prediction") + -->
<!--   ylab("density") + -->
<!--   labs(title = "Effect of sensors filtering based on the preliminary analysis", -->
<!--        subtitle = "calibration of a single log(LAD) with site/origin random effects", -->
<!--        color = "filter sensors | median LAD") + -->

<!--   scale_color_manual(values = c("salmon", "forestgreen")) + -->
<!--   theme_bw() + -->
<!--   theme(plot.title = element_text(hjust = 0.5), -->
<!--         plot.subtitle = element_text(hjust = 0.5), -->
<!--         legend.position = "top") + -->
<!--   guides(colour = guide_legend(title.position = "top", title.hjust = 0.5)) -->



<!-- # Get the legend and titles and remove it from first graphic -->
<!-- plot_exp1_title <- cowplot::get_title(plot_exp1_lad) -->
<!-- plot_exp1_subtitle <- cowplot::get_subtitle(plot_exp1_lad) -->
<!-- plot_exp1_legend <- cowplot::get_legend(plot_exp1_lad) -->

<!-- plot_exp1_lad <- plot_exp1_lad +  -->
<!--   theme(legend.position = "none") + -->
<!--   labs(title = NULL, subtitle = NULL) -->




<!-- # Plot the MAE -->
<!-- plot_exp1_mae <- eval_exp1 %>%  -->

<!--   ggplot(aes(x = MAE, color = mod_label)) + -->
<!--   geom_density(linewidth = 0.5) + -->

<!--   xlab("Mean Absolute Error between PACLs") + -->
<!--   ylab("density") + -->
<!--   scale_color_manual(values = c("salmon", "forestgreen")) + -->
<!--   theme_bw() + -->
<!--   theme(legend.position = "none") -->



<!-- # Combine graphs -->
<!-- cowplot::plot_grid( -->

<!--   plot_exp1_title, -->
<!--   plot_exp1_subtitle, -->

<!--   plot_exp1_legend, -->

<!--   cowplot::plot_grid( -->
<!--     plot_exp1_lad, plot_exp1_mae, -->
<!--     nrow = 1, rel_widths = c(1, 1) -->
<!--   ), -->

<!--   ncol = 1, rel_heights = c(1, 1, 2, 12) -->
<!-- ) -->
<!-- ``` -->


<!-- ### Observe convergence -->

<!-- ```{r} -->
<!-- trace_exp1 <- out_exp1 %>%  -->
<!--   purrr::map(~.x$outputs %>%  -->
<!--                getSample(start = 0,  -->
<!--                          end = NULL,  -->
<!--                          thin = 1, -->
<!--                          coda = TRUE) %>% -->
<!--                purrr::map(~as.data.frame(.x) %>% -->
<!--                             dplyr::mutate(iteration = row_number()) %>% -->
<!--                             dplyr::relocate(iteration)) %>% -->
<!--                dplyr::bind_rows(.id = "subchain")) %>% -->
<!--   dplyr::bind_rows(.id = "id_simu") %>%  -->

<!--   tidyr::pivot_longer(!c(id_simu, subchain, iteration), -->
<!--                       names_to = "parameter", -->
<!--                       values_to = "estimate") %>%  -->

<!--   dplyr::left_join(out_list$exp_design, by = "id_simu") %>%  -->
<!--   dplyr::mutate( -->
<!--     sensor_label = ifelse(filter_sensors, "WITH filter", "NO filter") -->
<!--   ) %>%  -->

<!--   dplyr::filter(parameter %in% c("intercept", "sigma_log", "sigma_origin_log", "sigma_site_log")) -->


<!-- trace_exp1 %>%  -->

<!--   ggplot(aes(y = estimate, x = iteration, color = subchain)) + -->
<!--   facet_grid(cols = vars(parameter), rows = vars(sensor_label), -->
<!--              scales = "free") + -->

<!--   geom_line() + -->
<!--   geom_vline(xintercept = max(trace_exp1$iteration) - n_analysis_exp1, -->
<!--              linetype = "dashed") + -->

<!--   labs(title = "Convergence of the models with or without sensors filtering", -->
<!--        subtitle = "calibration of a single log(LAD) without site/origin random effects") + -->

<!--   theme_bw() + -->
<!--   theme(plot.title = element_text(hjust = 0.5), -->
<!--         plot.subtitle = element_text(hjust = 0.5)) -->
<!-- ``` -->



## Clean model: species X DBH with covariance

100,000 iterations and 3 chains

```{r}
load("output/calib/out_20251227_completeModelv2.Rdata")

# Parameters
n_analysis_clean <- 1000
thinning_clean <- 1

out_list$exp_design
```


### Computation time

```{r}
out_list$output %>% 
  purrr::map(~data.frame(
    model = .x$id_model,
    chain = .x$i_chain,
    time_hours = as.numeric(.x$computation_time, 
                            units = "hours"))) %>% 
  dplyr::bind_rows() %>% 
  as.data.frame()
```


### Observe convergence

```{r}
trace_clean <- out_list$output %>% 
  purrr::map(~.x$output) %>% 
  setNames(out_list$output %>% purrr::map(~paste(.x$id_model, .x$i_chain, sep = "_"))) %>% 
  purrr::map(~.x %>% 
               getSample(start = 0, 
                         end = NULL, 
                         thin = 10,
                         coda = TRUE) %>%
               purrr::map(~as.data.frame(.x) %>%
                            dplyr::mutate(iteration = row_number()) %>%
                            dplyr::relocate(iteration)) %>%
               dplyr::bind_rows(.id = "subchain")) %>%
  dplyr::bind_rows(.id = "id_simu") %>%
  tidyr::separate(id_simu, c("model", "chain"), sep = "_") %>% 
  
  # Called the non species-specific model a mean species 
  dplyr::select(model, chain, subchain, iteration,
                sigma_log, sigma_site_log, sigma_origin_log,
                sigma_intercept_log, sigma_dbh_log,
                intercept, dbh,
                mean_intercept, mean_dbh, rho_raw,
                contains("z_intercept"), 
                contains("z_dbh")) %>% 
  
  dplyr::mutate(
    mean_intercept = coalesce(intercept, mean_intercept),
    mean_dbh = coalesce(dbh, mean_dbh)
  ) %>% 
  dplyr::select(-c(intercept, dbh)) %>% 
  
  tidyr::pivot_longer(!c(model, chain, subchain, iteration),
                      names_to = "parameter",
                      values_to = "estimate")



# Model sigmas
trace_clean %>% 
  
  dplyr::filter(parameter %in% c("sigma_log", "sigma_site_log", "sigma_origin_log")) %>% 
  
  ggplot(aes(y = estimate, x = iteration, 
             color = chain, linetype = subchain)) +
  facet_grid(parameter~model, scales = "free") +
  geom_line() +
  geom_vline(xintercept = max(trace_clean$iteration) - n_analysis_clean/10,
             linetype = "dashed") +
  
  labs(title = "Convergence of the sigma parameters") +
  
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))


# Model intercepts
trace_clean %>% 
  
  dplyr::filter(grepl("intercept", parameter),
                !grepl("z_", parameter)) %>% 
  
  ggplot(aes(y = estimate, x = iteration, 
             color = chain, linetype = subchain)) +
  facet_grid(parameter~model, scales = "free") +
  geom_line() +
  
  geom_vline(xintercept = max(trace_clean$iteration) - n_analysis_clean/10,
             linetype = "dashed") +
  
  labs(title = "Convergence of the intercept parameters") +
  
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))


trace_clean %>% 
  
  dplyr::filter(model != 1,
                grepl("intercept", parameter),
                grepl("z_", parameter)) %>% 
  
  dplyr::mutate(id = paste(
    gsub("z_intercept.", "", parameter),
    "_",
    model
  )) %>% 
  
  ggplot(aes(y = estimate, x = iteration, 
             color = chain, linetype = subchain)) +
  facet_wrap(~id, scales = "free") +
  geom_line() +
  
  geom_vline(xintercept = max(trace_clean$iteration) - n_analysis_clean/10,
             linetype = "dashed") +
  
  labs(title = "Convergence of the intercept parameters") +
  
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))


# Model dbh
trace_clean %>% 
  
  dplyr::filter(grepl("dbh", parameter),
                !grepl("z_", parameter)) %>% 
  
  ggplot(aes(y = estimate, x = iteration, 
             color = chain, linetype = subchain)) +
  facet_grid(parameter~model, scales = "free") +
  geom_line() +
  
  geom_vline(xintercept = max(trace_clean$iteration) - n_analysis_clean/10,
             linetype = "dashed") +
  geom_hline(yintercept = 0) +
  
  labs(title = "Convergence of the dbh parameters") +
  
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))


trace_clean %>% 
  
  dplyr::filter(model != 1,
                grepl("dbh", parameter),
                grepl("z_", parameter)) %>% 
  
  dplyr::mutate(id = paste(
    gsub("z_dbh.", "", parameter),
    "_",
    model
  )) %>% 
  
  ggplot(aes(y = estimate, x = iteration, 
             color = chain, linetype = subchain)) +
  facet_wrap(~id, scales = "free") +
  geom_line() +
  
  geom_vline(xintercept = max(trace_clean$iteration) - n_analysis_clean/10,
             linetype = "dashed") +
  
  labs(title = "Convergence of the intercept parameters") +
  
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))


# Rho parameter
trace_clean %>% 
  
  dplyr::filter(parameter == "rho_raw",
                model == 3) %>% 
  dplyr::mutate(rho = 2*plogis(estimate) - 1) %>% 
  
  ggplot(aes(y = rho, x = iteration, 
             color = chain, linetype = subchain)) +
  facet_grid(chain~subchain, scales = "free") +
  geom_line() +
  
  geom_vline(xintercept = max(trace_clean$iteration) - n_analysis_clean/10,
             linetype = "dashed") +
  geom_hline(yintercept = 0) +
  
  labs(title = "Convergence of the rho parameter",
       subtitle = "Model 3: speciesXdbh with covariance") +
  
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```


### Effect of DBH for each species

```{r}
dbh_cm_small <- 10
dbh_cm_large <- 60

# Compute mean LAD distribution
params_clean <- out_list$output %>% 
  purrr::map(~.x$output) %>% 
  setNames(out_list$output %>% purrr::map(~paste(.x$id_model, .x$i_chain, sep = "_"))) %>% 
  purrr::map(~.x %>% 
               getSample(start = nrow(.x$chain[[1]]) - n_analysis_clean, 
                         end = NULL, 
                         thin = thinning_clean,
                         coda = TRUE) %>%
               purrr::map(~as.data.frame(.x) %>%
                            dplyr::mutate(iteration = row_number()) %>%
                            dplyr::relocate(iteration)) %>%
               dplyr::bind_rows(.id = "subchain")) %>%
  dplyr::bind_rows(.id = "id_simu") %>% 
  tidyr::separate(id_simu, c("model", "chain"), sep = "_") %>% 
  
    # Compute the LAD for each species
  dplyr::select(model, chain, subchain, iteration,
                sigma_log, sigma_site_log, sigma_origin_log,
                sigma_intercept_log, sigma_dbh_log,
                intercept, dbh,
                mean_intercept, mean_dbh,
                contains("z_intercept"), contains("z_dbh"),
                rho_raw) %>% 
  
  dplyr::mutate(
    mean_intercept = coalesce(intercept, mean_intercept),
    mean_dbh = coalesce(dbh, mean_dbh)
  ) %>% 
  dplyr::select(-c(intercept, dbh)) %>% 
  
  tidyr::pivot_longer(!c(model, chain, subchain, iteration,
                         sigma_log, sigma_site_log, sigma_origin_log,
                         sigma_intercept_log, sigma_dbh_log,
                         mean_intercept, mean_dbh, rho_raw),
                      names_pattern = "z_(.*)\\.(.*)",
                      names_to = c("param", "species"),
                      values_to = "z") %>% 
  
  tidyr::pivot_wider(values_from = "z", 
                     names_from = "param",
                     names_prefix = "z_") %>% 
  
  dplyr::mutate(
    
    # Exponentiate sigmas
    sigma_mod = exp(sigma_log),
    sigma_site = exp(sigma_site_log),
    sigma_origin = exp(sigma_origin_log),
    sigma_intercept = ifelse(is.na(sigma_intercept_log), 0, exp(sigma_intercept_log)),
    sigma_dbh = ifelse(is.na(sigma_dbh_log), 0, exp(sigma_dbh_log)),
    
    # Compute the rho parameter (covariance)
    rho_raw = ifelse(is.na(rho_raw), 0, rho_raw),
    rho = 2*plogis(rho_raw) - 1,
    sqrt1mr2 = sqrt(1 - rho^2),
    
    # Set to 0 if z are NA
    z_intercept = ifelse(is.na(z_intercept), 0, z_intercept),
    z_dbh = ifelse(is.na(z_dbh), 0, z_dbh),
    
    # Compute the species specific intercept and dbh effect
    intercept_spspe = mean_intercept + sigma_intercept * z_intercept,
    dbh_spspe = mean_dbh + sigma_dbh * (rho * z_intercept + sqrt1mr2 *z_dbh)
  ) %>% 
  
  # Compute variance (do not forget that we fit a log_normal LAD, thus consider variance term when back transforming)
  dplyr::mutate(
    variance_sum = sigma_mod^2 + sigma_site^2 + sigma_origin^2 + sigma_intercept^2 + sigma_dbh^2
  )
  

# Observe covariance parameter (same between species)
params_clean %>% 
  dplyr::group_by(model, chain, subchain) %>% 
  dplyr::summarise(
    rho_lower = quantile(rho, 0.025),
    rho_median = median(rho),
    rho_upper = quantile(rho, 0.975)
  )

# Get models
mod_names <- c("mean species", "sp-specific no covar", "sp_specific with covar")

# Plot LAD prediction along dbh for a mean species gradient for each model 
for (i in 1:nrow(out_list$exp_design)) {
  
  tmp_plt <- tidyr::crossing(
    params_clean %>% 
      dplyr::filter(model == i),
    dbh_cm = seq(
      quantile(out_list$setup[[1]]$dbh_vect, 0.025),
      quantile(out_list$setup[[1]]$dbh_vect, 0.975),
      length.out = 100
    )
  ) %>% 
    
    dplyr::mutate(
      dbh_std = (dbh_cm - out_list$setup[[1]]$dbh_mean) / out_list$setup[[1]]$dbh_sd
    ) %>% 
    
    dplyr::mutate(
      lad = exp(intercept_spspe + dbh_std * dbh_spspe + 0.5*variance_sum)
    ) %>% 
    
    dplyr::group_by(model, chain, subchain, species, dbh_cm) %>% 
    dplyr::summarise(
      lad_median = median(lad),
      lad_lower = quantile(lad, 0.025),
      lad_upper = quantile(lad, 0.975)
    ) %>% 
    
    ggplot(aes(y = lad_median, x = dbh_cm, 
               color = chain, linetype = subchain)) +
    facet_wrap(~species, scales = "free_y") +
    
    geom_line() +
    geom_ribbon(aes(ymin = lad_lower, ymax = lad_upper,
                    fill = chain, linetype = subchain),
                color = NA,
                alpha = 0.4) +
    
    xlab("DBH (in cm)") +
    ylab("LAD prediction") +
    labs(title = paste("LAD predictions for model", mod_names[i]),
         subtitle = "between 2.5% and 97.5% quantiles of all species observed DBH") +
    
    theme_bw() +
    theme(legend.position = "right",
          plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5))
  
  print(tmp_plt)
}

# Plot LAD prediction for two dbh
for (i in 1:nrow(out_list$exp_design)) {
  
  lad_clean_2sizes <- tidyr::crossing(
    params_clean %>% 
      dplyr::filter(model == i),
    tree_size = c("small", "large")
  ) %>% 
    
    dplyr::mutate(
      dbh_cm = ifelse(tree_size == "small",
                      dbh_cm_small,
                      dbh_cm_large),
      
      dbh_std = (dbh_cm - out_list$setup[[1]]$dbh_mean) / out_list$setup[[1]]$dbh_sd
      
    ) %>% 
    
    dplyr::mutate(
      lad = exp(intercept_spspe + dbh_std * dbh_spspe + 0.5*variance_sum)
    ) %>% 
    
    dplyr::group_by(chain, species, tree_size) %>% 
    dplyr::summarise(
      lad_lower = quantile(lad, 0.025),
      lad_median = median(lad),
      lad_upper = quantile(lad, 0.975)
    ) %>% 
    
    dplyr::mutate(species = gsub("_", "", species),
                  order = case_match(species,
                                     c("Abiesalba", "Larixdecidua",
                                       "Piceaabies", "Pinussylvestris",
                                       "Pseudotsugamenziesii") ~ "gymnosperm",
                                     c("Carpinusbetulus", "Fagussylvatica",
                                       "Quercussp", "other") ~ "angiosperm"))
  
  tmp_plt <- lad_clean_2sizes %>%
    
    ggplot(aes(y = interaction(tree_size, species),
               color = species, shape = order)) +
    facet_wrap(~chain, scales = "free_x") +
    
    geom_pointrange(mapping = aes(x = lad_median, 
                                  xmin = lad_lower, 
                                  xmax = lad_upper)) +
    
    scale_y_discrete(NULL, guide = "axis_nested") +
    xlab("LAD distribution") +
    ylab("") +
    labs(title = paste("LAD predictions for model", mod_names[i]),
         subtitle = paste0("for a small tree (dbh = ",
                           dbh_cm_small,
                           "cm) and a large tree (dbh = ",
                           dbh_cm_large,
                           "cm)"),
         colour = "species") +
    
    theme_bw() +
    theme(legend.position = "top",
          plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5),
          axis.text.y = element_text(size = 7)) +
    guides(colour = "none")
  
  
  print(tmp_plt)
}
```



## Effect of BAxDBH

100,000 iterations and 1 chain

```{r}
load("output/calib/out_20251218_dbhXbatot.Rdata")

# Parameters
n_analysis_clean <- 15000
thinning_clean <- 15

out_list$exp_design
```

### Computation time

```{r}
out_list$output %>% 
  purrr::map(~data.frame(
    id_model = .x$id_model,
    time_hours = as.numeric(.x$computation_time, 
                            units = "hours"))) %>% 
  dplyr::bind_rows() %>% 
  as.data.frame()
```

### Observe convergence

```{r}
trace_clean <- out_list$output %>% 
  purrr::map(~.x$output) %>% 
  setNames(out_list$output %>% purrr::map(~.x$id_model)) %>% 
  purrr::map(~.x %>% 
               getSample(start = 0, 
                         end = NULL, 
                         thin = 1,
                         coda = TRUE) %>%
               purrr::map(~as.data.frame(.x) %>%
                            dplyr::mutate(iteration = row_number()) %>%
                            dplyr::relocate(iteration)) %>%
               dplyr::bind_rows(.id = "subchain")) %>%
  dplyr::bind_rows(.id = "id_model") %>% 
  
  # Called the non species-specific model a mean species 
  dplyr::select(id_model, subchain, iteration,
                sigma_log, sigma_site_log, sigma_origin_log,
                intercept, dbh, batot, dbhXbatot) %>% 
  tidyr::pivot_longer(!c(id_model, subchain, iteration),
                      names_to = "parameter",
                      values_to = "estimate")


# Model sigmas
trace_clean %>% 
  
  dplyr::filter(parameter %in% c("sigma_log", "sigma_site_log", "sigma_origin_log")) %>% 
  
  ggplot(aes(y = estimate, x = iteration, color = subchain)) +
  facet_grid(parameter~id_model, scales = "free") +
  geom_line() +
  geom_vline(xintercept = max(trace_clean$iteration) - n_analysis_clean,
             linetype = "dashed") +
  
  labs(title = "Convergence of the sigma parameters",
       subtitle = "species*dbh with covariance") +
  
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))


# Model predictors
trace_clean %>% 
  
  dplyr::filter(parameter %in% c("intercept", "dbh", "batot", "dbhXbatot")) %>% 
  
  ggplot(aes(y = estimate, x = iteration, 
             color = id_model, linetype = subchain)) +
  facet_wrap(~parameter, scales = "free", nrow = 1) +
  geom_line() +
  
  geom_vline(xintercept = max(trace_clean$iteration) - n_analysis_clean,
             linetype = "dashed") +
  geom_hline(yintercept = 0) +
  
  labs(title = "Convergence of the predictors parameters",
       subtitle = "species*dbh with covariance") +
  
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5),
        legend.position = "top")
```


### Effect of DBH X batot on a mean species

```{r}
tar_load(output_params)
tar_load(models_setup)

# Define modalities for graphs
dbh_cm_small <- 10
dbh_cm_large <- 60

batot_m2ha_low <- 10
batot_m2ha_high <- 40


# Plot LAD prediction along dbh for a mean species gradient for each model 
data_plt_dbhXbatot <- dplyr::bind_rows(
  
  # Effect of DBH for two BATOT
  tidyr::crossing(
    var_x = "dbh",
    output_params[[1]],
    dbh_cm = seq(
      quantile(models_setup[[1]]$dbh_vect, 0.025),
      quantile(models_setup[[1]]$dbh_vect, 0.975),
      length.out = 100
    ),
    compet_intensity = c("low", "high")
  ),
  
  # Effect of BATOT for two DBH
  tidyr::crossing(
    var_x = "batot",
    output_params[[1]],
    batot_m2ha = seq(
      quantile(models_setup[[1]]$batot_vect, 0.025),
      quantile(models_setup[[1]]$batot_vect, 0.975),
      length.out = 100
    ),
    tree_size = c("small", "large")
  )
  
) %>% 
  
  dplyr::mutate(
    
    # Set ref modalities for plot
    dbh_cm = ifelse(var_x == "batot",
                    ifelse(tree_size == "small",
                           dbh_cm_small,
                           dbh_cm_large),
                    dbh_cm),
                    
    batot_m2ha = ifelse(var_x == "dbh",
                    ifelse(compet_intensity == "low",
                           batot_m2ha_low,
                           batot_m2ha_high),
                    batot_m2ha),
    
    # Exponentiate sigmas
          sigma_mod = exp(sigma_log),
          sigma_site = exp(sigma_site_log),
          sigma_origin = exp(sigma_origin_log),
          
    # Compute variance (do not forget that we fit a log_normal LAD, 
    # thus consider variance term when back transforming)
    variance_sum = sigma_mod^2 + sigma_site^2 + sigma_origin^2,
    
    # Restandardize predictors
    dbh_std = (dbh_cm - models_setup[[1]]$dbh_mean) / models_setup[[1]]$dbh_sd,
    batot_std = (batot_m2ha - models_setup[[1]]$batot_mean) / models_setup[[1]]$batot_sd
  ) %>% 
  
  dplyr::mutate(
    lad = exp(intercept + 
                dbh_std * dbh + 
                batot_std * batot +
                dbh_std * batot_std * dbhXbatot + 
                0.5*variance_sum)
  ) 


## ------- LAD = f(DBH) for two BATOT ----
data_plt_dbhXbatot %>% 
  dplyr::filter(var_x == "dbh") %>% 
  
  dplyr::group_by(dbh_cm, compet_intensity) %>% 
  dplyr::summarise(
    lad_median = median(lad),
    lad_lower = quantile(lad, 0.025),
    lad_upper = quantile(lad, 0.975)
  ) %>% 
  
  ggplot(aes(y = lad_median, x = dbh_cm, color = compet_intensity)) +

  geom_line() +
  geom_ribbon(aes(ymin = lad_lower, ymax = lad_upper,
                  fill = compet_intensity),
              color = NA,
              alpha = 0.4) +
  
  xlab("DBH (in cm)") +
  ylab("LAD prediction") +
  labs(title = "LAD models along a DBH gradient",
       subtitle = "between 2.5% and 97.5% quantiles of all species observed DBH\nfor a total basal area of either 10m2ha (low) or 40m2ha (high)") +
  
  theme_bw() +
  theme(legend.position = "right",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  scale_color_manual(values = c("low" = "olivedrab", "high" = "darkgreen")) +
  scale_fill_manual(values = c("low" = "olivedrab", "high" = "darkgreen"))


## ------- LAD = f(BATOT) for two DBH ----
data_plt_dbhXbatot %>% 
  dplyr::filter(var_x == "batot") %>% 
  
  dplyr::group_by(batot_m2ha, tree_size) %>% 
  dplyr::summarise(
    lad_median = median(lad),
    lad_lower = quantile(lad, 0.025),
    lad_upper = quantile(lad, 0.975)
  ) %>% 
  
  ggplot(aes(y = lad_median, x = batot_m2ha, color = tree_size)) +

  geom_line() +
  geom_ribbon(aes(ymin = lad_lower, ymax = lad_upper,
                  fill = tree_size),
              color = NA,
              alpha = 0.4) +
  
  xlab("Total basal area (in m2/ha)") +
  ylab("LAD prediction") +
  labs(title = "LAD models along a BATOT gradient",
       subtitle = "between 2.5% and 97.5% quantiles of all plots observed BATOT\nfor a tree DBH of either 10cm (small) or 60cm (large)") +
  
  theme_bw() +
  theme(legend.position = "right",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```


# Output analysis

```{r}
tar_load(data_calib)

data_calib <- data_calib %>% 
  purrr::map(~.x$trees) %>% 
  dplyr::bind_rows() %>% 
  
  dplyr::mutate(
    order = case_match(species_calib,
                       c("Abies_alba", "Larix_decidua",
                         "Picea_abies", "Pinus_sylvestris",
                         "Pseudotsuga_menziesii") ~ "gymnosperm",
                       c("Carpinus_betulus", "Fagus_sylvatica",
                         "Quercus_sp", "other") ~ "angiosperm")
  )
```


```{r}
tar_load(data_output_tree)
tar_load(data_output_stand)
tar_load(data_output_light)
tar_load(LAD_CONTROL)
```

## Observe initial data

```{r}
mod_cor <- lm(data = data_output_tree, 
              formula = batot_m2ha ~ order)
summary(mod_cor)
```
### Stand variables

```{r}
ggplot(data_output_tree, aes(y = batot_m2ha, x = order, color = order)) +
  geom_boxplot() +
  theme_bw() +
  xlab("Tree clade") +
  ylab("Stand basal area (in m2/ha)")

ggplot(data_output_tree, aes(y = dbh_cm, x = order, color = order)) +
  geom_boxplot() +
  theme_bw() +
  xlab("Tree clade") +
  ylab("Tree DBH (in cm)")

ggplot(data_output_tree, aes(y = batot_m2ha, x = species_calib, 
                                  color = species_calib)) +
  geom_boxplot() +
  theme_bw() +
  xlab("Tree species") +
  ylab("Stand basal area (in m2/ha)")

ggplot(data_output_tree, aes(y = dbh_cm, x = species_calib, 
                                  color = species_calib)) +
  geom_boxplot() +
  theme_bw() +
  xlab("Tree species") +
  ylab("Tree DBH (in cm)")

ggplot(data_output_tree, aes(y = dbh_cm, x = batot_m2ha, color = order)) +
  geom_point() +
  theme_bw() +
  xlab("Stand basal area (in m2/ha)") +
  ylab("Tree DBH (in cm)")
  
ggplot(data_output_tree, aes(y = dbh_cm, x = batot_m2ha, color = species_calib)) +
  geom_point() +
  theme_bw() +
  xlab("Stand basal area (in m2/ha)") +
  ylab("Tree DBH (in cm)")
```


### Crown dimensions

```{r}
ggplot(data_calib, aes(y = h_m, 
                       x = dbh_cm, 
                       color = batot_m2ha)) +
  facet_wrap(~order) +
  geom_point() +
  geom_smooth(method = "gam") +
  theme_bw() +
  scale_color_viridis_c() +
  xlab("Tree DBH (in cm)") +
  ylab("Tree height (in m)")

ggplot(data_calib, aes(y = hbase_m, 
                       x = dbh_cm, 
                       color = batot_m2ha)) +
  facet_wrap(~order) +
  geom_point() +
  geom_smooth(method = "gam") +
  theme_bw() +
  scale_color_viridis_c() +
  xlab("Tree DBH (in cm)") +
  ylab("Crown base height (in m)")

ggplot(data_calib, aes(y = h_m - hbase_m, 
                       x = dbh_cm, 
                       color = batot_m2ha)) +
  facet_wrap(~order) +
  geom_point() +
  geom_smooth(method = "gam") +
  theme_bw() +
  scale_color_viridis_c() +
  xlab("Tree DBH (in cm)") +
  ylab("Crown depth (in m)")

ggplot(data_calib, aes(y = (rn_m + rs_m + re_m + rw_m) / 4, 
                       x = dbh_cm, 
                       color = batot_m2ha)) +
  facet_wrap(~order) +
  geom_point() +
  geom_smooth(method = "gam") +
  theme_bw() +
  scale_color_viridis_c() +
  xlab("Tree DBH (in cm)") +
  ylab("Mean crown radius (in m)")



ggplot(data_output_tree, aes(y = volume_m3, 
                             x = dbh_cm, 
                             color = batot_m2ha)) +
  facet_wrap(~order) +
  geom_point() +
  geom_smooth(method = "gam") +
  theme_bw() +
  scale_color_viridis_c() +
  xlab("Tree DBH (in cm)") +
  ylab("Tree crown volume (in m3)")
```


## Tree-level consequences on tree leaf area

```{r}
# --------- Prediction of LAD --------
data_output_tree %>% 
  
  ggplot(aes(y = lad_model_median, x = dbh_cm, color = batot_m2ha)) +
  geom_pointrange(aes(ymin = lad_model_lower, ymax = lad_model_upper)) +
  geom_hline(yintercept = LAD_CONTROL, linetype = "dashed", 
             color = "salmon", linewidth = 1.05) +
  
  xlab("DBH (in cm)") +
  ylab("Predicted leaf area density (in m2/ha)") +
  
  theme_bw() +
  theme(legend.position = "right",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  scale_color_viridis_c()


# --------- Prediction of LA --------
data_output_tree %>% 
  dplyr::select(site_name, id_tree, dbh_cm, batot_m2ha, species_calib,
                contains("la_"), -contains("diff_la")) %>% 
  tidyr::pivot_longer(
    !c(site_name, id_tree, species_calib, dbh_cm, batot_m2ha),
    names_pattern = "la_(.*)_(.*)",
    names_to = c("lad_model", "var"),
    values_to = "leaf_area_m2"
  ) %>% 
  tidyr::pivot_wider(
    names_from = "var",
    values_from = "leaf_area_m2"
  ) %>% 
  
  ggplot(aes(y = median, x = dbh_cm, color = batot_m2ha)) +
  facet_wrap(~lad_model) +
  geom_pointrange(aes(ymin = lower, ymax = upper)) +
  
  xlab("DBH (in cm)") +
  ylab("Total leaf area (in m2)") +
  
  theme_bw() +
  theme(legend.position = "top",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  scale_color_viridis_c()


# ------- Differences in LA -----
data_output_tree %>% 
  
  ggplot(aes(y = diff_la_median, x = dbh_cm, color = batot_m2ha)) +
  geom_pointrange(aes(ymin = diff_la_lower, ymax = diff_la_upper)) +
  
  xlab("DBH (in cm)") +
  ylab("Difference in LA between control and predicted LAD") +
  
  theme_bw() +
  theme(legend.position = "right",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  scale_color_viridis_c()
```


## Stand-level consequences on leaf area index LAI

```{r}
# --------- Prediction of LAI --------
data_output_stand %>% 
  dplyr::select(site_name, batot_m2ha, 
                contains("lai_model"), contains("lai_control")) %>% 
  tidyr::pivot_longer(
    !c(site_name, batot_m2ha),
    names_pattern = "lai_(.*)_(.*)",
    names_to = c("lad_model", "var"),
    values_to = "lai_m2m2"
  ) %>% 
  tidyr::pivot_wider(
    names_from = "var",
    values_from = "lai_m2m2"
  ) %>% 
  
  ggplot(aes(y = median, x = batot_m2ha, color = lad_model)) +
  geom_pointrange(aes(ymin = lower, ymax = upper)) +
  geom_smooth(method = "lm") +
  
  xlab("Total basal area (in m2/ha)") +
  ylab("Stand leaf area index (in m2/m2)") +
  
  theme_bw() +
  theme(legend.position = "top",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) 


# ------- Differences in LAI -----
data_output_stand %>% 
  
  ggplot(aes(y = diff_lai_median, x = batot_m2ha)) +
  geom_pointrange(aes(ymin = diff_lai_lower, ymax = diff_lai_upper)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  
  geom_smooth(method = "lm") +
  
  xlab("Total basal area (in m2/ha)") +
  ylab("Difference in LAI between control and predicted LAD") +
  
  theme_bw() +
  theme(legend.position = "right",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

## Consequences on light

### Tree-level

```{r}
# --------- Prediction of intercepted energy --------
data_output_light$trees %>% 
  dplyr::left_join(data_output_tree %>% 
                     dplyr::select(site = site_name, batot_m2ha,
                                   species_calib,
                                   id_tree, dbh_cm),
                   by = c("site", "id_tree")) %>% 
  dplyr::select(site, batot_m2ha, 
                id_tree, dbh_cm, species_calib,
                contains("lci_")) %>% 
  tidyr::pivot_longer(
    !c(site, batot_m2ha, id_tree, dbh_cm, species_calib),
    names_pattern = "lci_(.*)_(.*)",
    names_to = c("var", "lad_model"),
    values_to = "lci"
  ) %>% 
  tidyr::pivot_wider(
    names_from = "var",
    values_from = "lci"
  ) %>% 
  
  ggplot(aes(y = median, x = dbh_cm, color = batot_m2ha)) +
  facet_wrap(~lad_model) +
  geom_pointrange(aes(ymin = lower, ymax = upper)) +

  scale_color_viridis_c() +
  
  xlab("Total basal area (in m2/ha)") +
  ylab("Mean proportion of above canopy light PACL") +
  
  theme_bw() +
  theme(legend.position = "top",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) 
```

### Stand-level

```{r}
data_output_light$stand %>% 
  dplyr::left_join(data_output_stand %>% 
                     dplyr::select(site = site_name, batot_m2ha),
                   by = "site") %>% 
  dplyr::select(site, batot_m2ha, 
                contains("pacl_mean")) %>% 
  tidyr::pivot_longer(
    !c(site, batot_m2ha),
    names_pattern = "pacl_mean_(.*)_(.*)",
    names_to = c("var", "lad_model"),
    values_to = "pacl_mean"
  ) %>% 
  tidyr::pivot_wider(
    names_from = "var",
    values_from = "pacl_mean"
  ) %>% 
  
  ggplot(aes(y = median, x = batot_m2ha, color = lad_model)) +
  geom_pointrange(aes(ymin = lower, ymax = upper)) +
  geom_smooth(method = "lm") +
  
  xlab("Total basal area (in m2/ha)") +
  ylab("Mean proportion of above canopy light PACL") +
  
  theme_bw() +
  theme(legend.position = "top",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) 
```
