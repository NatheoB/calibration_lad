---
title: "LAD calibration"
output: 
  html_document:
    toc: true
date: "2025-09-24"
author: "Nath√©o BEAUCHAMP"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)
```

```{r}
library(targets)

library(dplyr)
library(tidyr)

library(ggplot2)
library(cowplot)
library(ggforce)
library(legendry)
library(grid)
library(gridExtra)
library(ggnewscale)

library(BayesianTools)
library(coda)
library(nlme)
```

# Motivation of the study

This study aims to calibrate Leaf Area Density (LAD), which is defined as the area of leaves per unit of tree crown volume (in $m^2.m^{-3}$). This parameter forms the basis of numerous process-based forest models, such as physiological models that consider photosynthesis and transpiration (e.g. SurEau by Cochard et al., 2021), and forest gap models that estimate light interception (e.g. ForCEEPS by Morin et al., 2021, and Samsara2 by Courbaud et al., 2015).

Although the leaf area density can be directly estimated from a sample of trees (Stadt & Lieffers, 2000), this method is laborious and difficult to replicate for every tree in a stand. Therefore, indirect methods can be employed, such as model inversion using a hemispherical photograph (Courbaud et al., 2003) or the more recent LiDAR methodology (Wei et al., 2020). However, there is a significant lack of research on LAD in the scientific literature, as there are no large-scale databases containing values for a wide range of European species. Furthermore, the few reported species-specific values vary considerably between studies (Ligot et al., 2014).

The aim of this study is to estimate leaf area density (LAD) for angiosperms and gymnosperms, considering eight main species: Fagus sylvatica, Picea abies, Quercus sp., Carpinus betulus, Pseudotsuga menziesii, Pinus sylvestris, Abies alba, Larix decidua with 'other species' (especially angiosperms). Additionally, Nock et al. (2008) demonstrated intraspecific variation in LAD, with intracrown leaf area decreasing by up to 40% with increasing tree age. This led us to consider the effect of diameter as well. Finally, as crown dimensions are very sensitive to local competition (Touzot et al., 2025), we hypothesise that LAD may also vary in response to competition.



# Methodology

In this study, we used a model inversion methodology, using the ray-tracing model SamsaraLight (Courbaud et al. 2003). We want to estimate the SamsaraLight tree-level parameter LAD using measurements of transmitted light $PACL_{obs}$ (for percentage of above light canopy), based on hemispherical photographs, within 45 plots of different composition and structures. For each plot, trees are inventoried with their crown dimensions, allowing to derive an estimated transmitted light $PACL_{est}$ on virtual sensors with the ray-tracing model SamsaraLight. By doing so, for each virtual sensor of each plot, we have the observed transmitted light $PACL_{obs}$, and the estimated transmitted light given a tree-level value of LAD $PACL_{est}$.

The aim of the calibration is to find a tree-level LAD model that minimize the error between $PACL_{obs}$ and $PACL_{est}$. To do so, we defined the LAD for a tree $i$, of species $s$ in a plot $p$ as $LAD_{i,s,p} = a_{0,s} + a_{0,p} + a_{1,s}.DBH_i + a_{2,s}.BAH_i + \epsilon$, where $a_{0,s}$ is a species-specific intercept, $a_{0,p}$ is a random hierarchical site effect, nested within an origin effect (4 origins of the plots within UCLouvain, INRAe, Cloture and IRRES), $DBH_i$ is the diameter at breast height of tree $i$ , with the associated estimated species-specific coefficient $a_{1,s}$, $BAH_i$ the competition index of the tree $i$ (*i.e.* the sum of basal area of trees higher than the tree $i$), with the associated estimated species-specific coefficient $a_{2,s}$, and $\epsilon$ the normal error term. We used a Bayesian approach to estimate the posterior distribution of parameters that minimize the log-likelihood between observed and simulated PACL. As computation of $PACL_{est}$ needs an external call of SamsaraLight model, we used the R package 'BayesianTools' to run a MCMC sampling of parameters with the "DREAMzs" sampling algorithm.

For this study, we used the SamsaraLight model with the R package SamsaraLight (Beauchamp et al., work in progress, intended for publication in the Journal of Open Source Software). The SamsaraLight model was initially developed in Java and included in the Capsis simulation platform (SamsaraLightLoader by Gauthier Ligot). It could be called from R software via the "RCapsis" R package (Fortin et al., 2021). To speed up calculation times and make SamsaraLight easier to use in an R environment, we created the "SamsaraLight" R package. The source code is written in C++ to enable fast calculations and communication with the R environment is handled by the Rcpp package (Eddelbuettel & Balamuta, 2018). The "SamsaRaLight" R package reduces calculation time compared to the previous method (the RCapsis R package calling the Java model SamsaRaLightLoader) as it does not require the creation of a Java server nor Java objects. It also facilitates the use of SamsaraLight within R, as it does not require the creation of an inventory file, instead using R objects and functions directly. The package is functional and stored in a GitHub repository, but it is still subject to private restrictions as discussions regarding co-authorship and the intellectual property rights of the source code need to be concluded.


# Preliminary analysis

```{r}
tar_load(lads_method1)
```

As a preliminary analysis, we tried to fit a mean LAD value for each sensor of each site. To do so, we run the SamsaraLight model on each stand by fixing the same crown LAD values of each tree, and for each sensor, we computed the residuals between the estimated PACL value on the virtual sensor, and the observed PACL on the field for this sensor. We did so for `r length(lads_method1)` values of LAD from `r min(lads_method1)` to `r max(lads_method1)`. By doing so, we could find for each sensor the LAD that minimizes the residuals.


```{r}
tar_load(output_lad_method1)
tar_load(lad_convergence_threshold)

output_lad_method1 <- output_lad_method1 %>% 
  dplyr::group_by(site) %>% 
  dplyr::mutate(
    site_lad = mean(best_lad[converged]),
    site_label = paste0(site, " - ", 
                        round(site_lad, 3), " - ",
                        sum(converged), "/", n())
  )

n_facets <- 9
n_plt <- length(unique(output_lad_method1$site)) %/% n_facets

for (i in 1:n_plt) {
  
  tmp_plt <- output_lad_method1 %>% 
    dplyr::filter(site %in% unique(output_lad_method1$site)[(1:9) + (i-1)*9]) %>% 
    
    ggplot(aes(y = best_lad, x = id_sensor, color = converged)) +
    facet_wrap(~site_label, scales = "free_x") +
    geom_point() +
    geom_hline(yintercept = lad_convergence_threshold,
               linetype = "dashed") +
    scale_color_manual(values = c("salmon", "forestgreen")) +
    theme_bw() +
    xlab("Id of the sensor") +
    ylab("Optimised LAD")
  
  print(tmp_plt)
}
```

Many sensors did not converged (i.e. best fitting LAD was 5 as the residuals function showed an asymptotic form). Indeed, we could increase as much as we want the trees's LAD, the estimated PACL could not decrease as much as the observed one. PACL is principally linked to the crown geometries, and secondary by the crown LAD. Thus, there are two cases where crown LAD did not influence PACL: (i) for open stands, where the high light on the ground comes principally from unobstructed rays, (ii) for highly crowded stands, where the very low light on the ground comes from the high number of intercepted crowns. Another reason could be linked to the wrong representation of leaves and crown above the sensor, where a simple branch can obstruct the sensor in the field where we considered a simple crown shape that result in incapabilities of representing such a light obstruction with the SamsaraLight model. Consequently, we remove the sensors that did not converged (465/1121 sensors), leading to remove consequently 3 sites where all sensors did not converged: Cloture11, Cloture15, Cloture2.

```{r}
# Fit logistic regression model

## Fit different models
model_linear <- glm(converged ~ punobs + pacl_obs, 
                    data = output_lad_method1, 
                    family = binomial)

model_poly <- glm(converged ~ poly(punobs, 2) + poly(pacl_obs, 2) + I(punobs*pacl_obs),
                  data = output_lad_method1, 
                  family = binomial)

model_svm <- e1071::svm(as.factor(converged) ~ punobs + pacl_obs, 
                        data = output_lad_method1, 
                        kernel = "radial", cost = 1, gamma = 0.1)

model_gam <- mgcv::gam(converged ~ s(punobs, pacl_obs), 
                       data = output_lad_method1, family = binomial)


## Create a grid to draw the decision boundary
xrange <- range(output_lad_method1$pacl_obs)
yrange <- range(output_lad_method1$punobs)
grid <- expand.grid(
  pacl_obs = seq(xrange[1], xrange[2], length.out = 200),
  punobs = seq(yrange[1], yrange[2], length.out = 200)
)

## Predict probabilities
# grid$prob <- predict(model_poly, newdata = grid, type = "response")
grid$pred <- predict(model_svm, newdata = grid)

## Plot the converged sensors all site confounded ----
ggplot(data = output_lad_method1,
                  mapping = aes(y = punobs * 100, x = pacl_obs * 100,
                                color = converged)) +
  geom_point() +
  scale_color_manual(values = c("salmon", "forestgreen")) +
  # stat_contour(data = grid, mapping = aes(z = prob),
  #              breaks = 0.5, color = "black", linewidth = 1) +
  geom_contour(data = grid, mapping = aes(z = as.numeric(pred)),
               breaks = 1.5, color = "black", linewidth = 1) +
  xlab("Observed total PACL (%)") +
  ylab("Part of total PACL unobstructed (%)") +
  labs(color = "Convergence",
       title = "Relationships between site-specific LAD convergence and PACL characteristics of a sensor",
       subtitle = paste0(sum(output_lad_method1$converged), 
                         "/", nrow(output_lad_method1), " sensors converged",
                         " (i.e. ", round(sum(output_lad_method1$converged) / nrow(output_lad_method1) * 100, 0), "%)")) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, size = 12),
        plot.subtitle = element_text(hjust = 0.5),
        legend.position = "top")
```


The mean LAD over all sensors that converged was about `r round(mean(output_lad_method1$best_lad[output_lad_method1$converged]), 3)`


# Bayesian calibration

50,000 iterations (20,000 burning), 5 chain, for BATOTxDBH model angio/gymno

```{r}
load("output/calib/out_20260127_dbhXbatot_spRandom.Rdata")
```

```{r}
data_trace <- output_models_list$output %>% 
  purrr::map(~.x$output) %>% 
  setNames(output_models_list$output %>% 
             purrr::map(~paste(.x$id_model, .x$i_rep, sep = "_")) %>% 
             unlist()) %>% 
  purrr::map(~.x %>% 
               getSample(coda = TRUE) %>%
               purrr::map(~as.data.frame(.x) %>%
                            dplyr::mutate(iteration = row_number()) %>%
                            dplyr::relocate(iteration)) %>%
               dplyr::bind_rows(.id = "subchain")
  ) %>% 
  
  dplyr::bind_rows(.id = "id_simu") %>% 
  tidyr::separate(id_simu, c("id_model", "chain"), remove = F) %>% 
  
  # Called the non species-specific model a mean species 
  dplyr::select(id_simu, id_model, chain, subchain, iteration,
                sigma_log, sigma_intercept_log,
                sigma_site_log, sigma_origin_log,
                contains("intercept"), contains("dbh"),
                contains("batot"), contains("dbhXbatot")) %>% 
  tidyr::pivot_longer(!c(id_simu, id_model, chain, subchain, iteration),
                      names_to = "parameter",
                      values_to = "estimate")
```


## Model sigmas

```{r}
data_trace %>% 
  
  dplyr::filter(parameter %in% c("sigma_log", "sigma_intercept_log",
                                 "sigma_site_log", "sigma_origin_log")) %>% 
  
  ggplot(aes(y = estimate, x = iteration, 
             color = chain, linetype = subchain)) +
  facet_wrap(~parameter, scales = "free", ncol = 2) +
  geom_line() +
  
  labs(title = "Convergence of the sigma parameters") +
  
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

   
## Predictor parameters

```{r}
data_trace %>% 
  
  dplyr::filter(parameter %in% c("mean_intercept", "dbh", "batot", "dbhXbatot")) %>% 
  
  ggplot(aes(y = estimate, x = iteration, 
             color = chain, linetype = subchain)) +
  facet_wrap(~parameter, scales = "free") +
  geom_line() +
  
  geom_hline(yintercept = 0) +
  
  labs(title = "Convergence of predictor parameters") +
  
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```


# Main analysis

```{r}
load("output/data/outdata_20260113_dbhXbatot_phylogeny.Rdata")

tar_load(data_stands)
tar_load(LAD_CONTROL)

data_crown <- data_stands %>% 
  purrr::map(~.x$trees) %>% 
  dplyr::bind_rows(.id = "site_name") %>% 
  dplyr::mutate(
    rmean_m = (rn_m + rs_m + re_m + rw_m) / 4,
    cdepth_m = h_m - hbase_m
  )

data_compo <- data_crown %>%  
  dplyr::group_by(site_name, batot_m2ha) %>% 
  dplyr::summarise(G_angio = sum( (phylogeny == "angiosperm") * G_ha ),
                   G_gymno = sum( (phylogeny == "gymnosperm") * G_ha ),
                   prop_angio = G_angio / sum(G_ha))

data_output_tree <- output_data_list$data_output_tree
data_output_stand <- output_data_list$data_output_stand
data_output_light_trees <- output_data_list$data_output_light$trees
data_output_light_stand <- output_data_list$data_output_light$stand
```

```{r}
# Define modalities for graphs
params <- output_models_list$params[[1]]

batot_m2ha_low <- 10
batot_m2ha_high <- 40
```


## LAD predictions from model calibration

```{r}
## ------- LAD = f(DBH) for two BATOT ----
tidyr::crossing(
    params,
    dbh_cm = seq(
      quantile(output_models_list$setup[[1]]$dbh_vect, 0.025),
      quantile(output_models_list$setup[[1]]$dbh_vect, 0.975),
      length.out = 100
    ),
    compet_intensity = c("low", "high")
  ) %>% 
  
  dplyr::mutate(
    
    # Set ref modalities for plot
    batot_m2ha = ifelse(compet_intensity == "low",
                        batot_m2ha_low,
                        batot_m2ha_high),
    
    # Exponentiate sigmas
    sigma_mod = exp(sigma_log),
    sigma_site = exp(sigma_site_log),
    sigma_origin = exp(sigma_origin_log),
    sigma_intercept = exp(sigma_intercept_log),
    
    # Compute variance (do not forget that we fit a log_normal LAD, 
    # thus consider variance term when back transforming)
    variance_sum = sigma_mod^2 + sigma_site^2 + sigma_origin^2 + sigma_intercept^2,
    
    # Restandardize predictors
    dbh_std = (dbh_cm - output_models_list$setup[[1]]$dbh_mean) /
      output_models_list$setup[[1]]$dbh_sd,
    
    batot_std = (batot_m2ha - output_models_list$setup[[1]]$batot_mean) /
      output_models_list$setup[[1]]$batot_sd
  ) %>% 
  
  dplyr::mutate(
    lad = exp(mean_intercept + 
                dbh_std * dbh + 
                batot_std * batot +
                dbh_std * batot_std * dbhXbatot + 
                0.5*variance_sum)
  ) %>% 
  
  # Compute summary statistics
  dplyr::group_by(rep, dbh_cm, compet_intensity) %>% 
  dplyr::summarise(
    lad_median = median(lad),
    lad_lower = quantile(lad, 0.025),
    lad_upper = quantile(lad, 0.975)
  ) %>% 
  
  ggplot(aes(y = lad_median, x = dbh_cm, color = compet_intensity)) +
  facet_wrap(~rep) +
  
  geom_line() +
  geom_ribbon(aes(ymin = lad_lower, ymax = lad_upper,
                  fill = compet_intensity),
              color = NA,
              alpha = 0.4) +
  
  xlab("DBH (in cm)") +
  ylab("LAD prediction") +
  labs(title = "LAD models along a DBH gradient",
       subtitle = "between 2.5% and 97.5% quantiles of all species observed DBH\nfor a total basal area of either 10m2ha (low) or 40m2ha (high)") +
  
  theme_bw() +
  theme(legend.position = "top",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  scale_color_manual(values = c("low" = "olivedrab", "high" = "darkgreen")) +
  scale_fill_manual(values = c("low" = "olivedrab", "high" = "darkgreen"))
```


## Estimate LAD on initial data

```{r}
data_output_tree %>% 
  
  ggplot(aes(y = lad_model_median, x = dbh_cm, color = batot_m2ha)) +
  facet_wrap(~phylogeny) +
  
  geom_pointrange(aes(ymin = lad_model_lower, ymax = lad_model_upper),
                  alpha = 0.5, size = 0.2) +
  scale_color_viridis_c(direction = -1) +
  
  geom_hline(yintercept = LAD_CONTROL, linetype = "dashed", 
             color = "black", linewidth = 1) +
  
  xlab("DBH (in cm)") +
  ylab("Predicted leaf area density (in m2/ha)") +
  
  theme_bw() +
  theme(legend.position = "right",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```



## Link predicted LAD to observed tree crown volume

```{r}
data_output_tree %>% 

  ggplot(aes(y = lad_model_median, x = volume_m3, color = batot_m2ha)) +
  facet_wrap(~phylogeny) +
  
  geom_pointrange(aes(ymin = lad_model_lower, ymax = lad_model_upper),
                  alpha = 0.5, size = 0.2) +
  scale_color_viridis_c(direction = -1) +

  geom_hline(yintercept = LAD_CONTROL, linetype = "dashed", 
             color = "black", linewidth = 1) +
  
  xlab("Crown volume (in m3)") +
  ylab("Predicted leaf area density (in m2/ha)") +
  
  theme_bw() +
  theme(legend.position = "right",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```


## Tree-level consequences on total leaf area LA

```{r}
data_output_tree %>% 
  dplyr::select(site_name, id_tree, dbh_cm, batot_m2ha, species, phylogeny,
                contains("la_"), -contains("diff_la")) %>% 
  tidyr::pivot_longer(
    !c(site_name, id_tree, species, phylogeny, dbh_cm, batot_m2ha),
    names_pattern = "la_(.*)_(.*)",
    names_to = c("lad_model", "var"),
    values_to = "leaf_area_m2"
  ) %>% 
  tidyr::pivot_wider(
    names_from = "var",
    values_from = "leaf_area_m2"
  ) %>% 

  ggplot(aes(y = median, x = dbh_cm, color = batot_m2ha)) +
  facet_grid(lad_model~phylogeny) +
  
  # geom_point() +
  geom_pointrange(aes(ymin = lower, ymax = upper),
                  alpha = 0.5, size = 0.2) +
  scale_color_viridis_c(direction = -1) +
  
  geom_smooth(color = "salmon") +
  
  xlab("DBH (in cm)") +
  ylab("Total leaf area (in m2)") +
  
  theme_bw() +
  theme(legend.position = "right",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```


## Stand-level consequences on leaf area index LAI

```{r}
# --------- Observe effect on LAI  --------
data_output_stand %>% 
  dplyr::select(site_name, batot_m2ha, 
                contains("lai_model"), contains("lai_control")) %>% 
  tidyr::pivot_longer(
    !c(site_name, batot_m2ha),
    names_pattern = "lai_(.*)_(.*)",
    names_to = c("lad_model", "var"),
    values_to = "lai_m2m2"
  ) %>% 
  tidyr::pivot_wider(
    names_from = "var",
    values_from = "lai_m2m2"
  ) %>% 
  
  dplyr::left_join(data_compo %>% 
                     dplyr::select(site_name, prop_angio), 
                   by = "site_name") %>% 
  dplyr::filter(lad_model == "model") %>% 
  
  ggplot(aes(y = median, x = prop_angio, color = batot_m2ha)) +
  geom_pointrange(aes(ymin = lower, ymax = upper)) +
  geom_smooth(method = "lm", formula = y~x) +
  
  xlab("Proportion of angiosperms") +
  ylab("Stand leaf area index (in m2/m2)") +
  
  theme_bw() +
  theme(legend.position = "right",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) +
  scale_color_viridis_c(direction = -1)
```


## Stand-level comparison with control model

```{r}
data_output_stand %>% 
  dplyr::select(site_name, batot_m2ha, 
                contains("lai_model"), contains("lai_control")) %>% 
  tidyr::pivot_longer(
    !c(site_name, batot_m2ha),
    names_pattern = "lai_(.*)_(.*)",
    names_to = c("lad_model", "var"),
    values_to = "lai_m2m2"
  ) %>% 
  tidyr::pivot_wider(
    names_from = "var",
    values_from = "lai_m2m2"
  ) %>% 
  
  ggplot(aes(y = median, x = batot_m2ha, color = lad_model)) +
  geom_pointrange(aes(ymin = lower, ymax = upper)) +
  geom_smooth(method = "lm") +
  
  xlab("Total basal area (in m2/ha)") +
  ylab("Stand leaf area index (in m2/m2)") +
  
  theme_bw() +
  theme(legend.position = "top",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5)) 

data_output_light_stand %>% 
  dplyr::left_join(data_output_stand %>% 
                     dplyr::select(site = site_name, batot_m2ha),
                   by = "site") %>% 
  dplyr::select(site, batot_m2ha, 
                contains("pacl_mean")) %>% 
  tidyr::pivot_longer(
    !c(site, batot_m2ha),
    names_pattern = "pacl_mean_(.*)_(.*)",
    names_to = c("var", "lad_model"),
    values_to = "pacl_mean"
  ) %>% 
  tidyr::pivot_wider(
    names_from = "var",
    values_from = "pacl_mean"
  ) %>% 
  
  ggplot(aes(y = median, x = batot_m2ha, color = lad_model)) +
  geom_pointrange(aes(ymin = lower, ymax = upper)) +
  geom_smooth(method = "lm") +
  
  xlab("Total basal area (in m2/ha)") +
  ylab("Mean proportion of above canopy light PACL") +
  
  theme_bw() +
  theme(legend.position = "top",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```




# Appendix

## Basal area vs. compo

```{r}
ggplot(data_compo, aes(y = batot_m2ha, x = prop_angio)) +
  geom_point() +
  theme_bw() +
  xlab("Proprotion of angiosperms in BA") +
  ylab("Stand basal area (in m2/ha)")
```


## Basal area vs. DBH

```{r}
ggplot(data_output_tree, aes(y = batot_m2ha, x = phylogeny)) +
  geom_boxplot() +
  theme_bw() +
  xlab("Tree clade") +
  ylab("Stand basal area (in m2/ha)")

ggplot(data_output_tree, aes(y = dbh_cm, x = phylogeny)) +
  geom_boxplot() +
  theme_bw() +
  xlab("Tree clade") +
  ylab("Tree DBH (in cm)")

ggplot(data_output_tree, aes(y = batot_m2ha, 
                             x = species, color = species)) +
  geom_boxplot() +
  theme_bw() +
  xlab("Tree species") +
  ylab("Stand basal area (in m2/ha)")

ggplot(data_output_tree, aes(y = dbh_cm, 
                             x = species, color = species)) +
  geom_boxplot() +
  theme_bw() +
  xlab("Tree species") +
  ylab("Tree DBH (in cm)")

ggplot(data_output_tree, aes(y = dbh_cm, x = batot_m2ha)) +
  facet_wrap(~phylogeny) +
  geom_point() +
  theme_bw() +
  xlab("Stand basal area (in m2/ha)") +
  ylab("Tree DBH (in cm)")
  
ggplot(data_output_tree, aes(y = dbh_cm, x = batot_m2ha)) +
  facet_wrap(~species) +
  geom_point() +
  theme_bw() +
  xlab("Stand basal area (in m2/ha)") +
  ylab("Tree DBH (in cm)")
```


## Crown allometries

### Tree height

```{r}
coefs_height <- list("angiosperm" = NULL, "gymnosperm" = NULL)

for (p in c("angiosperm", "gymnosperm")) {
  
  print(paste0("Fit for ", p, "..."))
  
  data_crown_tmp <- data_crown %>% 
    dplyr::filter(phylogeny == p)
  
  mod_asympt_height <- h_m ~ 1.3 + b1 * (1-exp(-b2 * dbh_cm)) ^ b3
  vars_rs_height <- data.frame(var = c("b1", "b2", "b3"), 
                               start = c(quantile(data_crown_tmp$h_m, 
                                                  probs = 0.97)*0.8, 0.07, 0.9))
  
  mod_height <- nls(mod_asympt_height,
                    data = data_crown_tmp,
                    start = setNames(as.list(vars_rs_height$start),
                                     vars_rs_height$var),
                    lower = c(0.0001, 0.0001, 0.0001), algorithm = "port",
                    nls.control(maxiter = 1000, tol = 1e-1))

  coefs_height[[p]] <- data.frame(as.list(coefficients(mod_height)))
}

coefs_height <- coefs_height %>% dplyr::bind_rows(.id = "phylogeny")
coefs_height


data_pred_height <- expand.grid(
  dbh_cm = seq(
    min(data_crown$dbh_cm), max(data_crown$dbh_cm),
    length.out = 100
  ),
  phylogeny = c("angiosperm", "gymnosperm")
) %>% 
  
  # Estimate mean crown radius
  dplyr::left_join(coefs_height, by = "phylogeny") %>% 
  dplyr::mutate(h_m = 1.3 + b1 * (1-exp(-b2 * dbh_cm)) ^ b3)
```


```{r}
ggplot(data_crown, aes(y = h_m, x = dbh_cm)) +
  facet_wrap(~phylogeny) +
  
  geom_point(mapping = aes(color = batot_m2ha),
             alpha = 0.5) +
  scale_color_viridis_c(direction = -1) +

  geom_line(data = data_pred_height,
            linewidth = 1.1) +
  
  theme_bw() +
  xlab("Tree DBH (in cm)") +
  ylab("Tree height (in m)")
```


### Crown base height

```{r}
ggplot(data_crown, aes(y = hbase_m, 
                       x = dbh_cm, 
                       color = batot_m2ha)) +
  facet_wrap(~phylogeny) +
  geom_point() +
  
  theme_bw() +
  scale_color_viridis_c(direction = -1) +
  xlab("Tree DBH (in cm)") +
  ylab("Crown base height (in m)")
```


### Crown depth

```{r}
coefs_cdepth <- list("angiosperm" = NULL, "gymnosperm" = NULL)

for (p in c("angiosperm", "gymnosperm")) {
  
  print(paste0("Fit for ", p, "..."))
  
  data_crown_tmp <- data_crown %>% 
    dplyr::filter(phylogeny == p)
  
  init_par_cdepth <- coefficients(lm(log(cdepth_m) ~ log(dbh_cm), data_crown_tmp))

  mod_cdepth <- nlme::gnls(
    cdepth_m ~ (a1 + a3 * batot_m2ha) * (dbh_cm ^ a2),
    data = data_crown_tmp,
    params = list(a1 ~ 1, a2 ~ 1, a3 ~ 1),
    start = c(a1 = exp(init_par_cdepth[1]), a2 = init_par_cdepth[2], a3 = 0),
    control = gnlsControl(maxIter = 1000, tolerance = 0.1, nlsTol = 0.1)
  )

  coefs_cdepth[[p]] <- data.frame(as.list(coefficients(mod_cdepth)))
}

coefs_cdepth <- coefs_cdepth %>% dplyr::bind_rows(.id = "phylogeny")
coefs_cdepth


data_pred_cdepth <- expand.grid(
  dbh_cm = seq(
    min(data_crown$dbh_cm), max(data_crown$dbh_cm),
    length.out = 100
  ),
  compet_intensity = c("low", "high"),
  phylogeny = c("angiosperm", "gymnosperm")
) %>% 
  
  # Set ref modalities for plot
  dplyr::mutate(
    batot_m2ha = ifelse(compet_intensity == "low",
                        batot_m2ha_low,
                        batot_m2ha_high)
  ) %>% 
  
  # Estimate mean crown radius
  dplyr::left_join(coefs_cdepth, by = "phylogeny") %>% 
  dplyr::mutate(cdepth_m = (a1 + a3 * batot_m2ha) * (dbh_cm ^ a2))
```

```{r}
ggplot(data_crown, aes(y = cdepth_m, x = dbh_cm)) +
  facet_wrap(~phylogeny) +
  
  geom_point(mapping = aes(color = batot_m2ha),
             alpha = 0.5) +
  scale_color_viridis_c(direction = -1) +
  ggnewscale::new_scale_color() +
  
  geom_line(data = data_pred_cdepth,
            mapping = aes(color = compet_intensity),
            linewidth = 1.1) +
  scale_color_viridis_d() +
  
  theme_bw() +
  xlab("Tree DBH (in cm)") +
  ylab("Crown depth (in m)")
```



### Mean crown radius

```{r}
coefs_rmean <- list("angiosperm" = NULL, "gymnosperm" = NULL)

for (p in c("angiosperm", "gymnosperm")) {
  
  print(paste0("Fit for ", p, "..."))
  
  data_crown_tmp <- data_crown %>% 
    dplyr::filter(phylogeny == p)
  
  init_par_rmean <- coefficients(lm(log(rmean_m) ~ log(dbh_cm), data_crown_tmp))
  
  mod_no_compet <- nlme::gnls(
    rmean_m ~ a1 * (dbh_cm ^ a2),
    data = data_crown_tmp,
    params = list(a1 ~ 1, a2 ~ 1),
    start = c(a1 = exp(init_par_rmean[1]), a2 = init_par_rmean[2]),
    control = gnlsControl(maxIter = 1000, tolerance = 0.1, nlsTol = 0.1)
  )

  mod_compet <- nlme::gnls(
    rmean_m ~ (a1 + a3 * batot_m2ha) * (dbh_cm ^ a2),
    data = data_crown_tmp,
    params = list(a1 ~ 1, a2 ~ 1, a3 ~ 1),
    start = c(a1 = exp(init_par_rmean[1]), a2 = init_par_rmean[2], a3 = 0),
    control = gnlsControl(maxIter = 1000, tolerance = 0.1, nlsTol = 0.1)
  )

  print(anova(mod_no_compet, mod_compet))
  
  coefs_rmean[[p]] <- data.frame(as.list(coefficients(mod_compet)))
}

coefs_rmean <- coefs_rmean %>% dplyr::bind_rows(.id = "phylogeny")
coefs_rmean


data_pred_rmean <- expand.grid(
  dbh_cm = seq(
    min(data_crown$dbh_cm), max(data_crown$dbh_cm),
    length.out = 100
  ),
  compet_intensity = c("low", "high"),
  phylogeny = c("angiosperm", "gymnosperm")
) %>% 
  
  # Set ref modalities for plot
  dplyr::mutate(
    batot_m2ha = ifelse(compet_intensity == "low",
                        batot_m2ha_low,
                        batot_m2ha_high)
  ) %>% 
  
  # Estimate mean crown radius
  dplyr::left_join(coefs_rmean, by = "phylogeny") %>% 
  dplyr::mutate(rmean_m = (a1 + a3 * batot_m2ha) * (dbh_cm ^ a2))
```


```{r}
ggplot(data_crown, aes(y = rmean_m, x = dbh_cm)) +
  facet_wrap(~phylogeny) +
  
  geom_point(mapping = aes(color = batot_m2ha),
             alpha = 0.5) +
  scale_color_viridis_c(direction = -1) +
  ggnewscale::new_scale_color() +
  
  geom_line(data = data_pred_rmean,
            mapping = aes(color = compet_intensity),
            linewidth = 1.1) +
  scale_color_viridis_d() +
  
  theme_bw() +
  xlab("Tree DBH (in cm)") +
  ylab("Mean crown radius (in m)")
```



### Consequent crown volume

```{r}
ggplot(data_output_tree, aes(y = volume_m3, 
                             x = dbh_cm, 
                             color = batot_m2ha)) +
  facet_wrap(~phylogeny) +
  geom_point() +
  geom_smooth(method = "gam") +
  theme_bw() +
  scale_color_viridis_c(direction = -1) +
  xlab("Tree DBH (in cm)") +
  ylab("Crown volume (in m)")
```



