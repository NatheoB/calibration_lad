---
title: "LAD calibration"
output: 
  html_document:
    toc: true
date: "2025-09-24"
author: "Nath√©o BEAUCHAMP"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)
```

```{r}
library(targets)
library(dplyr)
library(tidyr)

library(ggplot2)
library(cowplot)
library(ggforce)
library(legendry)
library(grid)
library(gridExtra)

library(BayesianTools)
library(coda)
```

# Motivation of the study

This study aims to calibrate Leaf Area Density (LAD), which is defined as the area of leaves per unit of tree crown volume (in $m^2.m^{-3}$). This parameter forms the basis of numerous process-based forest models, such as physiological models that consider photosynthesis and transpiration (e.g. SurEau by Cochard et al., 2021), and forest gap models that estimate light interception (e.g. ForCEEPS by Morin et al., 2021, and Samsara2 by Courbaud et al., 2015).

Although the leaf area density can be directly estimated from a sample of trees (Stadt & Lieffers, 2000), this method is laborious and difficult to replicate for every tree in a stand. Therefore, indirect methods can be employed, such as model inversion using a hemispherical photograph (Courbaud et al., 2003) or the more recent LiDAR methodology (Wei et al., 2020). However, there is a significant lack of research on LAD in the scientific literature, as there are no large-scale databases containing values for a wide range of European species. Furthermore, the few reported species-specific values vary considerably between studies (Ligot et al., 2014).

The aim of this study is to estimate leaf area density (LAD) for nine different species/groups: Fagus sylvatica, Picea abies, Quercus sp., Carpinus betulus, Pseudotsuga menziesii, Pinus sylvestris, Abies alba, Larix decidua and 'other species'. Additionally, Nock et al. (2008) demonstrated intraspecific variation in LAD, with intracrown leaf area decreasing by up to 40% with increasing tree age. This led us to consider the effect of diameter as well. Finally, as crown dimensions are very sensitive to local competition (Touzot et al., 2025), we hypothesise that LAD may also vary in response to competition.

# Methodology

In this study, we used a model inversion methodology, using the ray-tracing model SamsaraLight (Courbaud et al. 2003). We want to estimate the SamsaraLight tree-level parameter LAD using measurements of transmitted light $PACL_{obs}$ (for percentage of above light canopy), based on hemispherical photographs, within 45 plots of different composition and structures. For each plot, trees are inventoried with their crown dimensions, allowing to derive an estimated transmitted light $PACL_{est}$ on virtual sensors with the ray-tracing model SamsaraLight. By doing so, for each virtual sensor of each plot, we have the observed transmitted light $PACL_{obs}$, and the estimated transmitted light given a tree-level value of LAD $PACL_{est}$.

The aim of the calibration is to find a tree-level LAD model that minimize the error between $PACL_{obs}$ and $PACL_{est}$. To do so, we defined the LAD for a tree $i$, of species $s$ in a plot $p$ as $LAD_{i,s,p} = a_{0,s} + a_{0,p} + a_{1,s}.DBH_i + a_{2,s}.BAH_i + \epsilon$, where $a_{0,s}$ is a species-specific intercept, $a_{0,p}$ is a random hierarchical site effect, nested within an origin effect (4 origins of the plots within UCLouvain, INRAe, Cloture and IRRES), $DBH_i$ is the diameter at breast height of tree $i$ , with the associated estimated species-specific coefficient $a_{1,s}$, $BAH_i$ the competition index of the tree $i$ (*i.e.* the sum of basal area of trees higher than the tree $i$), with the associated estimated species-specific coefficient $a_{2,s}$, and $\epsilon$ the normal error term. We used a Bayesian approach to estimate the posterior distribution of parameters that minimize the log-likelihood between observed and simulated PACL. As computation of $PACL_{est}$ needs an external call of SamsaraLight model, we used the R package 'BayesianTools' to run a MCMC sampling of parameters with the "DREAMzs" sampling algorithm.

For this study, we used the SamsaraLight model with the R package SamsaraLight (Beauchamp et al., work in progress, intended for publication in the Journal of Open Source Software). The SamsaraLight model was initially developed in Java and included in the Capsis simulation platform (SamsaraLightLoader by Gauthier Ligot). It could be called from R software via the "RCapsis" R package (Fortin et al., 2021). To speed up calculation times and make SamsaraLight easier to use in an R environment, we created the "SamsaraLight" R package. The source code is written in C++ to enable fast calculations and communication with the R environment is handled by the Rcpp package (Eddelbuettel & Balamuta, 2018). The "SamsaRaLight" R package reduces calculation time compared to the previous method (the RCapsis R package calling the Java model SamsaRaLightLoader) as it does not require the creation of a Java server nor Java objects. It also facilitates the use of SamsaraLight within R, as it does not require the creation of an inventory file, instead using R objects and functions directly. The package is functional and stored in a GitHub repository, but it is still subject to private restrictions as discussions regarding co-authorship and the intellectual property rights of the source code need to be concluded.

# Calibration plots

The 45 calibration plots comes from 4 different sources we wiil call IRRES (9 plots, Gauthier Ligot), CLOTURE (23 plots, Gauthier Ligot), INRAe (10 plots, Philippe Balandier) and UCLouvain (3 plots, Mathieu Jonard).

```{r}
plot_stand <- function(init_db, site, cell_size) {
  
  # Get trees inventory
  tmp_data_trees <- init_db$trees[[site]] %>% 
    dplyr::left_join(init_db$species[[site]], 
                     by = c("SpCode" = "SpCode_SamsaraLL")) %>% 
    dplyr::mutate(crown_type = "8E") %>% 
    dplyr::select(id_tree = Id, 
                  species_code = SpCode,
                  species_calib = sp_calib,
                  x = X, y = Y, dbh_cm = Dbh,
                  crown_type, h_m = H, hbase_m = CBH, hmax_m = CMRH,
                  rn_m = RN, rs_m = RS, re_m = RE, rw_m = RW,
                  crown_openess = CrownOpenness, crown_lad = LAD)
  
  
  # If the plot extent dataframe is empty, set it to the default one
  tmp_plot_extent <- init_db$plot_extents[[site]]
  
  if (!is.null(tmp_plot_extent)) {
    tmp_plot_extent <- tmp_plot_extent %>% 
      dplyr::select(x = X, y = Y)
  }
  
  use_rect_zone <- ifelse(is.null(tmp_plot_extent), TRUE, FALSE)
  
  
  # Create a square plot with the inventory in the center
  tmp_stand <- SamsaRaLight::create_rect_stand(tmp_data_trees, 
                                               cell_size, 
                                               tmp_plot_extent,
                                               use_rect_zone,
                                               fill_around = FALSE)
  
  
  # Add sensors and shift coordinates inside the rect stand
  tmp_stand$sensors <- init_db$sensors[[site]] %>% 
    dplyr::select(id_sensor = id, x, y, h_m = z) %>% 
    dplyr::mutate(
      x = x + tmp_stand$info$shift_x,
      y = y + tmp_stand$info$shift_y
    )
  
  # Add species information to the tree dataset
  data_plot <- init_db$plots %>% dplyr::filter(name == site)
  data_species <- init_db$species[[site]]
  
  data_trees <- tmp_stand$trees %>% 
    dplyr::left_join(data_species,
                     by = c("species_code" = "SpCode_SamsaraLL")) %>% 
    dplyr::mutate(Essence_Latin = factor(Essence_Latin, levels = data_species$Essence_Latin))
  
  
  ## Create cell dataframe
  cells_xcenter <- seq(tmp_stand$info$cell_size / 2, 
                       tmp_stand$info$cell_size * tmp_stand$info$n_cells_x - tmp_stand$info$cell_size / 2,
                       by = tmp_stand$info$cell_size)
  
  cells_ycenter <- seq(tmp_stand$info$cell_size / 2, 
                       tmp_stand$info$cell_size * tmp_stand$info$n_cells_y - tmp_stand$info$cell_size / 2,
                       by = tmp_stand$info$cell_size)
  
  data_cells <- expand.grid(
    x_center = cells_xcenter,
    y_center = cells_ycenter
  )
  
  
  # Create the plot
  stand_plot <- ggplot() +
    coord_equal() +
    
    # CELLS 
    geom_tile(data = data_cells, 
              mapping = aes(x = x_center, y = y_center), 
              fill = "white", color = "darkgray")
  
  
  # CORE POLYGON
  if (!is.null(tmp_stand$inv_zone_df)) {  
    stand_plot <- stand_plot +
      geom_polygon(data = tmp_stand$inv_zone_df,
                   mapping = aes(x = x, y = y),
                   fill = "yellow", color = "black", alpha = 0.5)
  }
  
  
  # TREES
  stand_plot <- stand_plot +
    geom_ellipse(data = data_trees, 
                 mapping = aes(x0 = x, y0 = y, 
                               a = (re_m + rw_m) / 2,
                               b = (rn_m + rs_m) / 2,
                               angle = 0,
                               fill = Essence_Latin)) +
    scale_fill_manual(values = data_species$Couleur) +
    labs(fill = "Species") +
    
    # SENSORS
    geom_rect(data = tmp_stand$sensors,
              mapping = aes(xmin = x - 0.5,
                            ymin = y - 0.5,
                            xmax = x + 0.5,
                            ymax = y + 0.5),
              color = "red", fill = "black") +
    
    # GRAPHIC
    scale_x_continuous(breaks = seq(0, tmp_stand$info$n_cells_x * tmp_stand$info$cell_size,
                                    by = tmp_stand$info$cell_size),
                       labels = round(seq(0, tmp_stand$info$n_cells_x * tmp_stand$info$cell_size,
                                          by = tmp_stand$info$cell_size),
                                      digits = 1)) +
    scale_y_continuous(breaks = seq(0, tmp_stand$info$n_cells_y * tmp_stand$info$cell_size,
                                    by = tmp_stand$info$cell_size),
                       labels = round(seq(0, tmp_stand$info$n_cells_y * tmp_stand$info$cell_size,
                                          by = tmp_stand$info$cell_size),
                                      digits = 1)) +
    xlab("") + ylab("") +
    
    labs(title = site,
         subtitle = paste0(round(tmp_stand$info$core_area_ha, 2), "ha - ",
                           round(tmp_stand$info$core_batot_m2ha, 2), "m2/ha - ",
                           nrow(tmp_stand$trees), "trees",
                           "\n",
                           "(long ", round(data_plot$longitude, 2), ", lat ", 
                           round(data_plot$latitude, 2), ") - ",
                           "slope = ", round(data_plot$slope, 1), 
                           ", aspect = ", round(data_plot$aspect),
                           ", northToX = ", round(data_plot$northToX))) +
    
    theme_minimal() +
    theme(panel.grid.minor = element_blank(),
          legend.position = "right",
          plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5)) 
  
  # Print plot
  plot(stand_plot)
}
```

```{r}
# Get data
tar_load(init_db)

# Set the cell size, which will not impact the study as we compute light only on sensors
cell_size <- 10

# Sites names
site_names <- init_db$plots$name
```

## IRRES

```{r}
for (site in site_names[grepl("IRRES", site_names)]) {
  plot_stand(init_db, site, cell_size)
}
```

## CLOTURE

```{r}
for (site in site_names[grepl("Cloture", site_names)]) {
  plot_stand(init_db, site, cell_size)
}
```

## INRAe

```{r}
for (site in site_names[unique(c(grep("Ventoux", site_names), grep("Lorris", site_names),  grep("Fontfreyde", site_names)))]) {
  plot_stand(init_db, site, cell_size)
}
```

## UCLouvain

```{r}
for (site in site_names[grepl("Baileux", site_names)]) {
  plot_stand(init_db, site, cell_size)
}
```


# Preliminary analysis

```{r}
tar_load(lads_method1)
```

As a preliminary analysis, we tried to fit a mean LAD value for each sensor of each site. To do so, we run the SamsaraLight model on each stand by fixing the same crown LAD values of each tree, and for each sensor, we computed the residuals between the estimated PACL value on the virtual sensor, and the observed PACL on the field for this sensor. We did so for `r length(lads_method1)` values of LAD from `r min(lads_method1)` to `r max(lads_method1)`. By doing so, we could find for each sensor the LAD that minimizes the residuals.


```{r}
tar_load(output_lad_method1)

output_lad_method1 <- output_lad_method1 %>% 
  dplyr::group_by(site) %>% 
  dplyr::mutate(
    site_lad = mean(best_lad[converged]),
    site_label = paste0(site, " - ", 
                        round(site_lad, 3), " - ",
                        sum(converged), "/", n())
  )

n_facets <- 9
n_plt <- length(unique(output_lad_method1$site)) %/% n_facets

for (i in 1:n_plt) {
  
  tmp_plt <- output_lad_method1 %>% 
    dplyr::filter(site %in% unique(output_lad_method1$site)[1:9*i]) %>% 
    
    ggplot(aes(y = best_lad, x = id_sensor, color = converged)) +
    facet_wrap(~site_label, scales = "free_x") +
    geom_point() +
    scale_color_manual(values = c("salmon", "forestgreen")) +
    theme_bw() +
    xlab("Id of the sensor") +
    ylab("Optimised LAD")
  
  print(tmp_plt)
}
```

Many sensors did not converged (i.e. best fitting LAD was 5 as the residuals function showed an asymptotic form). Indeed, we could increase as much as we want the trees's LAD, the estimated PACL could not decrease as much as the observed one. PACL is principally linked to the crown geometries, and secondary by the crown LAD. Thus, there are two cases where crown LAD did not influence PACL: (i) for open stands, where the high light on the ground comes principally from unobstructed rays, (ii) for highly crowded stands, where the very low light on the ground comes from the high number of intercepted crowns. Another reason could be linked to the wrong representation of leaves and crown above the sensor, where a simple branch can obstruct the sensor in the field where we considered a simple crown shape that result in incapabilities of representing such a light obstruction with the SamsaraLight model. Consequently, we remove the sensors that did not converged (465/1121 sensors), leading to remove consequently 3 sites where all sensors did not converged: Cloture11, Cloture15, Cloture2.

```{r}
# Fit logistic regression model

## Fit different models
model_linear <- glm(converged ~ punobs_horizontal + PACLobs, 
                    data = output_lad_method1, 
                    family = binomial)

model_poly <- glm(converged ~ poly(punobs_horizontal, 2) + poly(PACLobs, 2) + I(punobs_horizontal*PACLobs),
                  data = output_lad_method1, 
                  family = binomial)

model_svm <- e1071::svm(as.factor(converged) ~ punobs_horizontal + PACLobs, 
                        data = output_lad_method1, 
                        kernel = "radial", cost = 1, gamma = 0.1)

model_gam <- mgcv::gam(converged ~ s(punobs_horizontal, PACLobs), 
                       data = output_lad_method1, family = binomial)


## Create a grid to draw the decision boundary
xrange <- range(output_lad_method1$PACLobs)
yrange <- range(output_lad_method1$punobs_horizontal)
grid <- expand.grid(
  PACLobs = seq(xrange[1], xrange[2], length.out = 200),
  punobs_horizontal = seq(yrange[1], yrange[2], length.out = 200)
)

## Predict probabilities
# grid$prob <- predict(model_poly, newdata = grid, type = "response")
grid$pred <- predict(model_svm, newdata = grid)

## Plot the converged sensors all site confounded ----
ggplot(data = output_lad_method1,
                  mapping = aes(y = punobs_horizontal * 100, x = PACLobs * 100,
                                color = converged)) +
  geom_point() +
  scale_color_manual(values = c("salmon", "forestgreen")) +
  # stat_contour(data = grid, mapping = aes(z = prob),
  #              breaks = 0.5, color = "black", linewidth = 1) +
  geom_contour(data = grid, mapping = aes(z = as.numeric(pred)),
               breaks = 1.5, color = "black", linewidth = 1) +
  xlab("Observed total PACL (%)") +
  ylab("Part of total PACL unobstructed (%)") +
  labs(color = "Convergence",
       title = "Relationships between site-specific LAD convergence and PACL characteristics of a sensor",
       subtitle = paste0(sum(output_lad_method1$converged), 
                         "/", nrow(output_lad_method1), " sensors converged",
                         " (i.e. ", round(sum(output_lad_method1$converged) / nrow(output_lad_method1) * 100, 0), "%)")) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, size = 12),
        plot.subtitle = element_text(hjust = 0.5),
        legend.position = "top")
```


The mean LAD over all sensors that converged was about `r round(mean(output_lad_method1$best_lad[output_lad_method1$converged]), 3)`


# Bayesian calibration

```{r}
load("output/calib/out_20251202_clean.Rdata")
```


## Observe the effect of sensors filtering

A first Bayesian approach would be to also fit a mean LAD value on the sensors that converged with the previous method, by considering a hierarchical random effect (site into origin, mandatory according to the structure our our dataset).

The model can be written as:
$LAD_{p} = a_{0} + a_{0,p} + \epsilon$, where $a_{0}$ is the LAD intercept and $a_{0,p}$ is a random hierarchical site effect, nested within an origin effect (4 origins of the plots within UCLouvain, INRAe, Cloture and IRRES).


```{r}
mods_exp1 <- c("1_1", "1_2")
out_exp1 <- out_list$output[mods_exp1]  
```


### Computation time

```{r}
dplyr::left_join(
  
  # Experimental design
  out_list$exp_design %>% 
    dplyr::filter(id_simu %in% mods_exp1),
  
  # Comutation times
  out_exp1 %>% 
    purrr::map(~data.frame(time_hours = as.numeric(.x$computation_time, 
                                             units = "hours"))) %>% 
    dplyr::bind_rows(.id = "id_simu"),
  
  by = "id_simu"
) %>% 
  
  dplyr::select(id_mod, n_chains, n_iterations, 
                filter_sensors, 
                time_hours) %>% 
  as.data.frame()
```


### Compare models and intercept predictions

```{r plot_exp1}
# Get models evalution  outputs 
eval_exp1_list <- out_list$evaluation$indicators[mods_exp1] 



# Parameters
n_analysis_exp1 <- 5000
thinning_exp1 <- 1



# Compute mean LAD distribution
lad_exp1 <- out_exp1 %>% 
  purrr::map(~.x$outputs %>% 
               getSample(start = nrow(.x$outputs$chain[[1]]) - n_analysis_exp1, 
                         end = NULL, 
                         thin = thinning_exp1,
                         coda = TRUE) %>%
               purrr::map(~as.data.frame(.x) %>%
                            dplyr::mutate(iteration = row_number()) %>%
                            dplyr::relocate(iteration)) %>%
               dplyr::bind_rows(.id = "subchain")) %>%
  dplyr::bind_rows(.id = "id_simu") %>% 
  dplyr::mutate(
    sigma = exp(sigma_log),
    lad = exp(intercept + 0.5*sigma^2) # do not forget to add variance term, as here we compute the mean of a log-normal  
  ) %>% 
  dplyr::left_join(out_list$exp_design, by = "id_simu")



# Compute LAD summaries
summaries_exp1 <- lad_exp1 %>% 
  dplyr::group_by(id_simu, filter_sensors) %>% 
  dplyr::summarise(
    lad_qt025 = quantile(lad, 0.025),
    lad_median = quantile(lad, 0.5),
    lad_qt975 = quantile(lad, 0.975)
  ) %>% 
  dplyr::ungroup()

print(summaries_exp1 %>% as.data.frame())



# Create plot label
summaries_exp1 <- summaries_exp1 %>% 
  dplyr::mutate(mod_label = paste0(filter_sensors, " | ", round(lad_median, 3)))

lad_exp1 <- lad_exp1 %>% 
  dplyr::left_join(summaries_exp1, by = "id_simu")

eval_exp1 <- eval_exp1_list %>%
  dplyr::bind_rows(.id = "id_simu") %>% 
  dplyr::left_join(summaries_exp1, by = "id_simu")


# Compute summaries of MAE and RMSE
summaries_eval_exp1 <- eval_exp1 %>% 
  dplyr::group_by(id_simu, filter_sensors) %>% 
  dplyr::summarise(
    
    mae_qt025 = quantile(MAE, 0.025),
    mae_median = quantile(MAE, 0.5),
    mae_qt975 = quantile(MAE, 0.975),
    
    rmse_qt025 = quantile(RMSE, 0.025),
    rmse_median = quantile(RMSE, 0.5),
    rmse_qt975 = quantile(RMSE, 0.975)
    
  ) %>% 
  dplyr::ungroup()

print(summaries_eval_exp1 %>% as.data.frame())



# Plot summaries and distribution of LAD
plot_exp1_lad <- lad_exp1 %>% 

  ggplot(aes(x = lad, color = mod_label)) +
  
  geom_vline(data = summaries_exp1, 
             aes(xintercept = lad_qt025, color = mod_label),
             linewidth = 0.9, linetype = "dotted", alpha = 0.7) +
  geom_vline(data = summaries_exp1, 
             aes(xintercept = lad_median, color = mod_label),
             linewidth = 0.9, linetype = "dashed", alpha = 0.7) +
  geom_vline(data = summaries_exp1, 
             aes(xintercept = lad_qt975, color = mod_label),
             linewidth = 0.9, linetype = "dotted", alpha = 0.7) +
  
  geom_density(linewidth = 0.5) +
  
  xlab("Intercept prediction") +
  ylab("density") +
  labs(title = "Effect of sensors filtering based on the preliminary analysis",
       subtitle = "calibration of a single log(LAD) with site/origin random effects",
       color = "filter sensors | median LAD") +
  
  scale_color_manual(values = c("salmon", "forestgreen")) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5),
        legend.position = "top") +
  guides(colour = guide_legend(title.position = "top", title.hjust = 0.5))

  

# Get the legend and titles and remove it from first graphic
plot_exp1_title <- cowplot::get_title(plot_exp1_lad)
plot_exp1_subtitle <- cowplot::get_subtitle(plot_exp1_lad)
plot_exp1_legend <- cowplot::get_legend(plot_exp1_lad)

plot_exp1_lad <- plot_exp1_lad + 
  theme(legend.position = "none") +
  labs(title = NULL, subtitle = NULL)




# Plot the MAE
plot_exp1_mae <- eval_exp1 %>% 

  ggplot(aes(x = MAE, color = mod_label)) +
  geom_density(linewidth = 0.5) +

  xlab("Mean Absolute Error between PACLs") +
  ylab("density") +
  scale_color_manual(values = c("salmon", "forestgreen")) +
  theme_bw() +
  theme(legend.position = "none")



# Combine graphs
cowplot::plot_grid(
  
  plot_exp1_title,
  plot_exp1_subtitle,
  
  plot_exp1_legend,
  
  cowplot::plot_grid(
    plot_exp1_lad, plot_exp1_mae,
    nrow = 1, rel_widths = c(1, 1)
  ),
  
  ncol = 1, rel_heights = c(1, 1, 2, 12)
)
```


### Observe convergence

```{r}
trace_exp1 <- out_exp1 %>% 
  purrr::map(~.x$outputs %>% 
               getSample(start = 0, 
                         end = NULL, 
                         thin = 1,
                         coda = TRUE) %>%
               purrr::map(~as.data.frame(.x) %>%
                            dplyr::mutate(iteration = row_number()) %>%
                            dplyr::relocate(iteration)) %>%
               dplyr::bind_rows(.id = "subchain")) %>%
  dplyr::bind_rows(.id = "id_simu") %>% 
  
  tidyr::pivot_longer(!c(id_simu, subchain, iteration),
                      names_to = "parameter",
                      values_to = "estimate") %>% 
  
  dplyr::left_join(out_list$exp_design, by = "id_simu") %>% 
  dplyr::mutate(
    sensor_label = ifelse(filter_sensors, "WITH filter", "NO filter")
  ) %>% 
  
  dplyr::filter(parameter %in% c("intercept", "sigma_log", "sigma_origin_log", "sigma_site_log"))
 
  
trace_exp1 %>% 
  
  ggplot(aes(y = estimate, x = iteration, color = subchain)) +
  facet_grid(cols = vars(parameter), rows = vars(sensor_label),
             scales = "free") +
  
  geom_line() +
  geom_vline(xintercept = max(trace_exp1$iteration) - n_analysis_exp1,
             linetype = "dashed") +
  
  labs(title = "Convergence of the models with or without sensors filtering",
       subtitle = "calibration of a single log(LAD) without site/origin random effects") +
  
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```


## Is there an effect of species and tree diameter ?


```{r}
mods_exp3 <- c("1_2" = "control", 
               "2_1" = "dbh", 
               "3_1" = "species", 
               "3_2" = "dbh + species", 
               "4_1" = "dbh*species", 
               "4_2" = "dbh*species with covar")

out_exp3 <- out_list$output[names(mods_exp3)]  

mods_exp3


# Parameters
n_analysis_exp3 <- 1000
thinning_exp3 <- 1
```


### Computation time

```{r}
dplyr::left_join(
  
  # Experimental design
  out_list$exp_design %>% 
    dplyr::filter(id_simu %in% names(mods_exp3)),
  
  # Comutation times
  out_exp3 %>% 
    purrr::map(~data.frame(time_hours = as.numeric(.x$computation_time, 
                                             units = "hours"))) %>% 
    dplyr::bind_rows(.id = "id_simu"),
  
  by = "id_simu"
) %>% 
  
  dplyr::select(id_simu, n_chains, n_iterations, 
                intercept_per_sp, dbh_effect, dbh_per_sp, consider_covariance, 
                time_hours) %>% 
  as.data.frame()
```



### Compare models

```{r}
# Get models evalution and comparison outputs 
comp_exp3_list <- out_list$comparison[names(mods_exp3)] 
eval_exp3_list <- out_list$evaluation$indicators[names(mods_exp3)] 



# Compute the LOOIC
looic_exp3 <- comp_exp3_list %>% 
  purrr::map(
    function(x) {
      out <- x$LOOCV["looic",]
      str <- paste0(round(out[["Estimate"]], 2), 
                    " (SE ",
                    round(out[["SE"]], 2),
                    ")")
      data.frame(looic = str)
    }
  ) %>% 
  dplyr::bind_rows(.id = "id_simu")


# Create the data for MAE/RMSE
eval_exp3 <- eval_exp3_list %>%
  dplyr::bind_rows(.id = "id_simu") %>% 
  dplyr::left_join(out_list$exp_design, by = "id_simu")


# Compute summaries of MAE and RMSE
summaries_eval_exp3 <- eval_exp3 %>% 
  dplyr::mutate(str_mod = mods_exp3[id_simu]) %>% 
  dplyr::group_by(id_simu, str_mod, 
                  intercept_per_sp, dbh_effect, dbh_per_sp, consider_covariance) %>% 
  dplyr::summarise(
    
    mae_qt025 = quantile(MAE, 0.025),
    mae_median = quantile(MAE, 0.5),
    mae_qt975 = quantile(MAE, 0.975),
    
    rmse_qt025 = quantile(RMSE, 0.025),
    rmse_median = quantile(RMSE, 0.5),
    rmse_qt975 = quantile(RMSE, 0.975)
    
  ) %>% 
  dplyr::ungroup() %>% 
  dplyr::left_join(looic_exp3, by = "id_simu")


print(summaries_eval_exp3 %>% as.data.frame())


# Plot the MAE
eval_exp3 %>% 
  dplyr::mutate(
    str_mod = mods_exp3[id_simu]
  ) %>%

  ggplot(aes(x = MAE, color = str_mod)) +
  geom_density(linewidth = 0.5) +
  
  geom_vline(data = summaries_eval_exp3, 
             mapping = aes(xintercept = mae_median,
                           color = str_mod),
             linetype = "dotted",
             linewidth = 1.05) +

  xlab("Mean Absolute Error between PACLs") +
  ylab("density") +
  labs(title = "Compare the forms of DBH effect",
       subtitle = "calibration of log(LAD)",
       colour = "DBH models") +
  
  # scale_color_manual(values = c("coral", "cadetblue")) +
  theme_bw() +
  theme(legend.position = "right",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```


### Observe convergence

```{r}
trace_exp3 <- out_exp3 %>% 
  purrr::map(~.x$outputs %>% 
               getSample(start = 0, 
                         end = NULL, 
                         thin = 1,
                         coda = TRUE) %>%
               purrr::map(~as.data.frame(.x) %>%
                            dplyr::mutate(iteration = row_number()) %>%
                            dplyr::relocate(iteration)) %>%
               dplyr::bind_rows(.id = "subchain")) %>%
  dplyr::bind_rows(.id = "id_simu") %>% 
  
  # Called the non species-specific model a mean species 
  dplyr::select(id_simu, subchain, iteration,
                sigma_log, sigma_site_log, sigma_origin_log,
                sigma_intercept_log, sigma_dbh_log,
                mean_intercept, intercept,
                mean_dbh, dbh,
                rho_raw,
                contains("z_intercept"), 
                contains("z_dbh")) %>% 
  tidyr::pivot_longer(!c(id_simu, subchain, iteration),
                      names_to = "parameter",
                      values_to = "estimate")


for (id in names(mods_exp3)) {
  
  # Get model design 
  mod <- out_list$exp_design %>% 
    dplyr::filter(id_simu == id)
  
  # Model sigmas
  print(
    
    trace_exp3 %>% 
      
      dplyr::filter(id_simu == mod$id_simu,
                    parameter %in% c("sigma_log", "sigma_site_log", "sigma_origin_log")) %>% 
      
      ggplot(aes(y = estimate, x = iteration, color = subchain)) +
      facet_wrap(~parameter, scales = "free") +
      geom_line() +
      geom_vline(xintercept = max(trace_exp3$iteration) - n_analysis_exp3,
                 linetype = "dashed") +
      
      labs(title = "Convergence of the sigma parameters",
           subtitle = mods_exp3[[mod$id_simu]]) +
      
      theme_bw() +
      theme(plot.title = element_text(hjust = 0.5),
            plot.subtitle = element_text(hjust = 0.5))
    
  )
  
  # Model intercepts
  print(
    
    trace_exp3 %>% 
      
      dplyr::filter(id_simu == mod$id_simu,
                    grepl("intercept", parameter)) %>% 
      dplyr::mutate(parameter = gsub("intercept.", "", parameter),
                    parameter = gsub("_intercept", "", parameter)) %>% 
      
      ggplot(aes(y = estimate, x = iteration, color = subchain)) +
      facet_wrap(~parameter, scales = "free") +
      geom_line() +
      
      geom_vline(xintercept = max(trace_exp3$iteration) - n_analysis_exp3,
                 linetype = "dashed") +
      
      labs(title = "Convergence of the intercept parameters",
           subtitle = mods_exp3[[mod$id_simu]]) +
      
      theme_bw() +
      theme(plot.title = element_text(hjust = 0.5),
            plot.subtitle = element_text(hjust = 0.5))
    
  )
    
    # Model dbh
    print(
    
    trace_exp3 %>% 
      
      dplyr::filter(id_simu == mod$id_simu,
                    grepl("dbh", parameter)) %>% 
      dplyr::mutate(parameter = gsub("dbh.", "", parameter),
                    parameter = gsub("_dbh", "", parameter)) %>% 
      
      ggplot(aes(y = estimate, x = iteration, color = subchain)) +
      facet_wrap(~parameter, scales = "free") +
      geom_line() +
      
      geom_vline(xintercept = max(trace_exp3$iteration) - n_analysis_exp3,
                 linetype = "dashed") +
      geom_hline(yintercept = 0) +
      
      labs(title = "Convergence of the dbh parameters",,
           subtitle = mods_exp3[[mod$id_simu]]) +
      
      theme_bw() +
      theme(plot.title = element_text(hjust = 0.5),
            plot.subtitle = element_text(hjust = 0.5))
    
  )
}
```

### LAD predictions

#### For a mean species at a mean DBH

```{r}
# Compute mean LAD distribution
lad_exp3_meandbh <- out_exp3 %>% 
  purrr::map(~.x$outputs %>% 
               getSample(start = nrow(.x$outputs$chain[[1]]) - n_analysis_exp3, 
                         end = NULL, 
                         thin = thinning_exp3,
                         coda = TRUE) %>%
               purrr::map(~as.data.frame(.x) %>%
                            dplyr::mutate(iteration = row_number()) %>%
                            dplyr::relocate(iteration)) %>%
               dplyr::bind_rows(.id = "subchain")) %>%
  dplyr::bind_rows(.id = "id_simu") %>% 
  
  # Compute the mean LAD (either the intercept if no species-specific LAD, 
  # or the mean species otherwise) : intercept and mean_intercept are inversely at NA
  dplyr::select(id_simu, subchain, iteration,
                sigma_log, sigma_site_log, sigma_origin_log,
                sigma_intercept_log, sigma_dbh_log,
                intercept_noSP = intercept, intercept_meanSP = mean_intercept) %>% 
  
  dplyr::mutate(intercept = coalesce(intercept_noSP, intercept_meanSP)) %>% 
  
  
  # Replace NA of random effects by 0 (adding a 0 variance term do nothing)
  dplyr::mutate(
    sigma_mod = ifelse(is.na(sigma_log), 0, exp(sigma_log)),
    sigma_site = ifelse(is.na(sigma_site_log), 0, exp(sigma_site_log)),
    sigma_origin = ifelse(is.na(sigma_origin_log), 0, exp(sigma_origin_log)),
    sigma_intercept = ifelse(is.na(sigma_intercept_log), 0, exp(sigma_intercept_log)),
    sigma_dbh = ifelse(is.na(sigma_dbh_log), 0, exp(sigma_dbh_log))
  ) %>%
  
  # Compute variance (do not forget that we fit a log_normal LAD, thus consider variance term when back transforming)
  dplyr::mutate(
    variance_sum = sigma_mod^2 + sigma_site^2 + sigma_origin^2 + sigma_intercept^2 + sigma_dbh^2,
    
    lad = exp(intercept + 0.5*variance_sum)
  ) %>%
  
  # Add modalities
  dplyr::mutate(str_mod = mods_exp3[id_simu])


# Compute LAD summaries
summaries_exp3_meandbh <- lad_exp3_meandbh %>% 
  dplyr::group_by(str_mod) %>% 
  dplyr::summarise(
    lad_qt025 = quantile(lad, 0.025),
    lad_median = quantile(lad, 0.5),
    lad_qt975 = quantile(lad, 0.975)
  ) %>% 
  dplyr::ungroup() %>% 
  dplyr::arrange(lad_median)

print(summaries_exp3_meandbh %>% 
        as.data.frame())


# Plot LAD distribution for a mean species by models
lad_exp3_meandbh %>% 

  ggplot(aes(x = lad, color = str_mod)) +
  geom_density(linewidth = 0.5) +

  
  geom_vline(data = summaries_exp3_meandbh, 
             mapping = aes(xintercept = lad_median,
                           color = str_mod),
             linetype = "dotted",
             linewidth = 1.05) +
  
  xlab("LAD distribution") +
  ylab("density") +
  labs(title = "Mean LAD prediction for all models",
       subtitle = "for a mean species at a mean DBH (28cm)",
       colour = "models") +
  
  theme_bw() +
  theme(legend.position = "right",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

#### Effect of DBH on mean LAD

```{r}
# Compute mean LAD distribution
params_exp3_dbh <- out_exp3 %>% 
  purrr::map(~.x$outputs %>% 
               getSample(start = nrow(.x$outputs$chain[[1]]) - n_analysis_exp3, 
                         end = NULL, 
                         thin = thinning_exp3,
                         coda = TRUE) %>%
               purrr::map(~as.data.frame(.x) %>%
                            dplyr::mutate(iteration = row_number()) %>%
                            dplyr::relocate(iteration)) %>%
               dplyr::bind_rows(.id = "subchain")) %>%
  dplyr::bind_rows(.id = "id_simu") %>% 
  
  # Compute the mean LAD (either the intercept if no species-specific LAD, 
  # or the mean species otherwise) : intercept and mean_intercept are inversely at NA
  dplyr::select(id_simu, subchain, iteration,
                sigma_log, sigma_site_log, sigma_origin_log,
                sigma_intercept_log, sigma_dbh_log,
                intercept_noSP = intercept, intercept_meanSP = mean_intercept,
                dbh_noSP = dbh, dbh_meanSP = mean_dbh) %>% 
  
  dplyr::mutate(intercept = coalesce(intercept_noSP, intercept_meanSP),
                param_dbh = coalesce(dbh_noSP, dbh_meanSP),
                param_dbh = ifelse(is.na(param_dbh), 0, param_dbh)) %>% 
  
  # Replace NA of random effects by 0 (adding a 0 variance term do nothing)
  dplyr::mutate(
    sigma_mod = ifelse(is.na(sigma_log), 0, exp(sigma_log)),
    sigma_site = ifelse(is.na(sigma_site_log), 0, exp(sigma_site_log)),
    sigma_origin = ifelse(is.na(sigma_origin_log), 0, exp(sigma_origin_log)),
    sigma_intercept = ifelse(is.na(sigma_intercept_log), 0, exp(sigma_intercept_log)),
    sigma_dbh = ifelse(is.na(sigma_dbh_log), 0, exp(sigma_dbh_log))
  ) %>%
  
  # Compute variance (do not forget that we fit a log_normal LAD, thus consider variance term when back transforming)
  dplyr::mutate(
    variance_sum = sigma_mod^2 + sigma_site^2 + sigma_origin^2 + sigma_intercept^2 + sigma_dbh^2
  ) %>%
  
  # Add modalities
  dplyr::mutate(str_mod = mods_exp3[id_simu])
  

lad_exp3_dbh <- tidyr::crossing(
  params_exp3_dbh,
  dbh_cm = seq(
    quantile(out_list$setup$`1_2`$dbh_vect, 0.025),
    quantile(out_list$setup$`1_2`$dbh_vect, 0.975),
    length.out = 1000
  )
) %>% 
  
  dplyr::mutate(
    dbh_std = (dbh_cm - out_list$setup$`1_2`$dbh_mean) / out_list$setup$`1_2`$dbh_sd
  ) %>% 
  
  dplyr::mutate(
    lad = exp(intercept + dbh_std * param_dbh + 0.5*variance_sum)
  )

# Plot LAD prediction along dbh for a mean species gradient for each model 
lad_exp3_dbh %>% 

  dplyr::group_by(str_mod, subchain, dbh_cm) %>% 
  dplyr::summarise(
    lad_median = median(lad),
    lad_lower = quantile(lad, 0.025),
    lad_upper = quantile(lad, 0.975)
  ) %>% 
  
  ggplot(aes(y = lad_median, x = dbh_cm, 
             color = subchain)) +
  facet_wrap(~str_mod) +
  
  geom_line() +
  geom_ribbon(aes(ymin = lad_lower, ymax = lad_upper, fill = subchain),
              color = NA,
              alpha = 0.4) +
  
  xlab("DBH (in cm)") +
  ylab("LAD prediction") +
  labs(title = "LAD models along a DBH gradient",
       subtitle = "for a mean species between 2.5% and 97.5% quantiles of observed DBH",
       colour = "subchain") +
  
  theme_bw() +
  theme(legend.position = "right",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```


#### Species-specific at a mean DBH 

```{r}
# Compute mean LAD distribution
lad_exp3_meandbh_spspe <- out_exp3 %>% 
  purrr::map(~.x$outputs %>% 
               getSample(start = nrow(.x$outputs$chain[[1]]) - n_analysis_exp3, 
                         end = NULL, 
                         thin = thinning_exp3,
                         coda = TRUE) %>%
               purrr::map(~as.data.frame(.x) %>%
                            dplyr::mutate(iteration = row_number()) %>%
                            dplyr::relocate(iteration)) %>%
               dplyr::bind_rows(.id = "subchain")) %>%
  dplyr::bind_rows(.id = "id_simu") %>% 
  
  # Compute the LAD for each species
  dplyr::select(id_simu, subchain, iteration,
                sigma_log, sigma_site_log, sigma_origin_log,
                sigma_intercept_log, sigma_dbh_log,
                intercept_noSP = intercept, intercept_meanSP = mean_intercept,
                contains("z_intercept")) %>% 
  
  tidyr::pivot_longer(!c(id_simu, subchain, iteration,
                         sigma_log, sigma_site_log, sigma_origin_log,
                         sigma_intercept_log, sigma_dbh_log,
                         intercept_noSP, intercept_meanSP),
                      names_prefix = "z_intercept.",
                      names_to = "species",
                      values_to = "z_intercept") %>% 
  
  
  # Replace NA of random effects by 0 (adding a 0 variance term do nothing)
  dplyr::mutate(
    sigma_mod = ifelse(is.na(sigma_log), 0, exp(sigma_log)),
    sigma_site = ifelse(is.na(sigma_site_log), 0, exp(sigma_site_log)),
    sigma_origin = ifelse(is.na(sigma_origin_log), 0, exp(sigma_origin_log)),
    sigma_dbh = ifelse(is.na(sigma_dbh_log), 0, exp(sigma_dbh_log))
  ) %>% 
  dplyr::mutate(
    
    # Here do not consider variance form intercept as we compute species-specific intercept
    sigma_intercept = 0,
    
    # Compute the species specific intercept
    intercept_spspe = intercept_meanSP + exp(sigma_intercept_log) * z_intercept,
    
    # Get the intercept by keeping species-specific or signle intercept according to the model
    intercept = coalesce(intercept_noSP, intercept_spspe)
    ) %>% 
  
  # Compute variance (do not forget that we fit a log_normal LAD, thus consider variance term when back transforming)
  dplyr::mutate(
    variance_sum = sigma_mod^2 + sigma_site^2 + sigma_origin^2 + sigma_intercept^2 + sigma_dbh^2,
    
    lad = exp(intercept + 0.5*variance_sum)
  ) %>%
  
  # Add modalities
  dplyr::mutate(str_mod = mods_exp3[id_simu])


# Compute LAD summaries
summaries_exp3_meandbh_spspe <- lad_exp3_meandbh_spspe %>% 
  dplyr::group_by(str_mod, species) %>% 
  dplyr::summarise(
    lad_qt025 = quantile(lad, 0.025),
    lad_median = quantile(lad, 0.5),
    lad_qt975 = quantile(lad, 0.975)
  ) %>% 
  dplyr::ungroup() %>% 
  dplyr::arrange(str_mod, lad_median)

print(summaries_exp3_meandbh_spspe %>% 
        as.data.frame())


# Plot LAD distribution for each species, by models
summaries_exp3_meandbh_spspe %>% 

  ggplot(aes(y = species, color = species)) +
  facet_wrap(~str_mod, scales = "free_x") +
  geom_pointrange(mapping = aes(x = lad_median, 
                                xmin = lad_qt025, 
                                xmax = lad_qt975)) +
  
  xlab("LAD distribution") +
  ylab("") +
  labs(title = "Species-specific LAD prediction for all models",
       subtitle = "at a mean DBH (28cm)",
       colour = "species") +
  
  theme_bw() +
  theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))


lad_exp3_meandbh_spspe %>% 

  ggplot(aes(x = lad, color = species)) +
  facet_wrap(~str_mod, scales = "free") +
  geom_density(linewidth = 0.5) +
  
  xlab("LAD distribution") +
  ylab("density") +
  labs(title = "Species-specific LAD prediction for all models",
       subtitle = "at a mean DBH (28cm)",
       colour = "species") +
  
  theme_bw() +
  theme(legend.position = "right",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```

#### Effect of DBH for each species

```{r}
dbh_cm_small <- 10
dbh_cm_large <- 60

# Compute mean LAD distribution
params_exp3_dbh_spspe <- out_exp3 %>% 
  purrr::map(~.x$outputs %>% 
               getSample(start = nrow(.x$outputs$chain[[1]]) - n_analysis_exp3, 
                         end = NULL, 
                         thin = thinning_exp3,
                         coda = TRUE) %>%
               purrr::map(~as.data.frame(.x) %>%
                            dplyr::mutate(iteration = row_number()) %>%
                            dplyr::relocate(iteration)) %>%
               dplyr::bind_rows(.id = "subchain")) %>%
  dplyr::bind_rows(.id = "id_simu") %>% 
  
    # Compute the LAD for each species
  dplyr::select(id_simu, subchain, iteration,
                sigma_log, sigma_site_log, sigma_origin_log,
                sigma_intercept_log, sigma_dbh_log,
                intercept_noSP = intercept, intercept_meanSP = mean_intercept,
                dbh_noSP = dbh, dbh_meanSP = mean_dbh,
                contains("z_intercept"), contains("z_dbh"),
                rho_raw) %>% 
  
  tidyr::pivot_longer(!c(id_simu, subchain, iteration,
                         sigma_log, sigma_site_log, sigma_origin_log,
                         sigma_intercept_log, sigma_dbh_log,
                         intercept_noSP, intercept_meanSP,
                         dbh_noSP, dbh_meanSP, rho_raw),
                      names_pattern = "z_(.*)\\.(.*)",
                      names_to = c("param", "species"),
                      values_to = "z") %>% 
  
  tidyr::pivot_wider(values_from = "z", 
                     names_from = "param",
                     names_prefix = "z_") %>% 
  
  
  # Replace NA of random effects by 0 (adding a 0 variance term do nothing)
  dplyr::mutate(
    sigma_mod = ifelse(is.na(sigma_log), 0, exp(sigma_log)),
    sigma_site = ifelse(is.na(sigma_site_log), 0, exp(sigma_site_log)),
    sigma_origin = ifelse(is.na(sigma_origin_log), 0, exp(sigma_origin_log))
  ) %>% 
  dplyr::mutate(
    
    # Here do not consider variance form intercept as we compute species-specific intercept
    sigma_intercept = 0,
    sigma_dbh = 0,
    
    # Compute the rho parameter (covariance)
    rho_raw = ifelse(is.na(rho_raw), 0, rho_raw),
    rho = 2*plogis(rho_raw) - 1,
    sqrt1mr2 = sqrt(1 - rho^2),
    
    # Compute the species specific intercept and dbh effect
    intercept_spspe = intercept_meanSP + exp(sigma_intercept_log) * z_intercept,
    dbh_spspe = dbh_meanSP + exp(sigma_dbh_log) * (rho * z_intercept + sqrt1mr2 *z_dbh),
    
    # Get the intercept by keeping species-specific or signle intercept according to the model
    intercept = coalesce(intercept_noSP, intercept_spspe),
    param_dbh = coalesce(dbh_noSP, dbh_spspe),
    param_dbh = ifelse(is.na(param_dbh), 0, param_dbh)
    ) %>% 
  
  # Compute variance (do not forget that we fit a log_normal LAD, thus consider variance term when back transforming)
  dplyr::mutate(
    variance_sum = sigma_mod^2 + sigma_site^2 + sigma_origin^2 + sigma_intercept^2 + sigma_dbh^2
  ) %>%
  
  # Add modalities
  dplyr::mutate(str_mod = mods_exp3[id_simu])
  

# Observe covariance parameter (same between species)
params_exp3_dbh_spspe %>% 
  dplyr::filter(id_simu == "4_2", species == "Abies_alba") %>% 
  dplyr::summarise(
    rho_lower = quantile(rho, 0.025),
    rho_median = median(rho),
    rho_upper = quantile(rho, 0.975)
  )


# Plot LAD prediction for two dbh
lad_exp3_dbh_spspe_2sizes <- tidyr::crossing(
  params_exp3_dbh_spspe,
  tree_size = c("small", "large")
) %>% 
  
  dplyr::mutate(
    dbh_cm = ifelse(tree_size == "small",
                    dbh_cm_small,
                    dbh_cm_large),
    
    dbh_std = (dbh_cm - out_list$setup$`1_2`$dbh_mean) / out_list$setup$`1_2`$dbh_sd
    
  ) %>% 
  
  dplyr::mutate(
    lad = exp(intercept + dbh_std * param_dbh + 0.5*variance_sum)
  ) %>% 
  
  dplyr::group_by(str_mod, species, tree_size) %>% 
  dplyr::summarise(
    lad_lower = quantile(lad, 0.025),
    lad_median = median(lad),
    lad_upper = quantile(lad, 0.975)
  ) %>% 

  dplyr::mutate(species = gsub("_", "", species),
                order = case_match(species,
                                   c("Abiesalba", "Larixdecidua",
                                     "Piceaabies", "Pinussylvestris",
                                     "Pseudotsugamenziesii") ~ "gymnosperm",
                                   c("Carpinusbetulus", "Fagussylvatica",
                                     "Quercussp", "other") ~ "angiosperm"))




lad_exp3_dbh_spspe_2sizes %>%   
  ggplot(aes(y = interaction(species, tree_size),
             color = species, shape = order)) +
  facet_wrap(~str_mod, scales = "free_x") +
  geom_pointrange(mapping = aes(x = lad_median, 
                                xmin = lad_lower, 
                                xmax = lad_upper)) +
  
  scale_y_discrete(NULL, guide = "axis_nested") +
  xlab("LAD distribution") +
  ylab("") +
  labs(title = "Species-specific LAD prediction for all models",
       subtitle = paste0("for a small tree (dbh = ",
                         dbh_cm_small,
                         "cm) and a large tree (dbh = ",
                         dbh_cm_large,
                         "cm)"),
       colour = "species") +
  
  theme_bw() +
  theme(legend.position = "none",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5),
        axis.text.y = element_text(size = 6))
  

# Plot LAD for final model for two dbh
lad_exp3_dbh_spspe_2sizes %>%
  dplyr::filter(str_mod == "dbh*species with covar") %>% 
  
  ggplot(aes(y = interaction(species, tree_size),
             color = species, shape = order)) +
  geom_pointrange(mapping = aes(x = lad_median, 
                                xmin = lad_lower, 
                                xmax = lad_upper)) +
  
  geom_hline(yintercept = 9.5, linetype = "dashed", colour = "black") +
  
  scale_y_discrete(NULL, guide = "axis_nested") +
  xlab("LAD distribution") +
  ylab("") +
  labs(title = "Species-specific LAD prediction for 'dbh*species with covar' model",
       subtitle = paste0("for a small tree (dbh = ",
                         dbh_cm_small,
                         "cm) and a large tree (dbh = ",
                         dbh_cm_large,
                         "cm)"),
       colour = "species") +
  
  theme_bw() +
  theme(legend.position = "top",
        plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5),
        axis.text.y = element_text(size = 7)) +
     guides(colour = "none")



# Plot LAD prediction along dbh for a mean species gradient for each model 
species_vect <- unique(params_exp3_dbh_spspe$species)
for (sp in species_vect) {
  
  print(
    
    tidyr::crossing(
      params_exp3_dbh_spspe %>% 
        dplyr::filter(species == sp),
      dbh_cm = seq(
        quantile(out_list$setup$`1_2`$dbh_vect, 0.025),
        quantile(out_list$setup$`1_2`$dbh_vect, 0.975),
        length.out = 1000
      )
    ) %>% 
      
      dplyr::mutate(
        dbh_std = (dbh_cm - out_list$setup$`1_2`$dbh_mean) / out_list$setup$`1_2`$dbh_sd
      ) %>% 
      
      dplyr::mutate(
        lad = exp(intercept + dbh_std * param_dbh + 0.5*variance_sum)
      ) %>% 
      
      dplyr::group_by(str_mod, subchain, dbh_cm) %>% 
      dplyr::summarise(
        lad_median = median(lad),
        lad_lower = quantile(lad, 0.025),
        lad_upper = quantile(lad, 0.975)
      ) %>% 
      
      ggplot(aes(y = lad_median, x = dbh_cm, 
                 color = subchain)) +
      facet_wrap(~str_mod) +
      
      geom_line() +
      geom_ribbon(aes(ymin = lad_lower, ymax = lad_upper, fill = subchain),
                  color = NA,
                  alpha = 0.4) +
      
      xlab("DBH (in cm)") +
      ylab("LAD prediction") +
      labs(title = "LAD models along a DBH gradient",
           subtitle = paste0(sp, " - between 2.5% and 97.5% quantiles of all species observed DBH"),
           colour = "subchain") +
      
      theme_bw() +
      theme(legend.position = "right",
            plot.title = element_text(hjust = 0.5),
            plot.subtitle = element_text(hjust = 0.5))
  )
}
```






<!-- # Going further with the Bayesian approach -->

<!-- # Limits -->

<!-- **There is still problem of convergence,** we need to explore why. Intercept and slope can compensate for each other (e.g., high intercept with negative slope vs low intercept with positive slope), the model may not be fully identifiable with the current data: Standardize predictors (like dbh and BALh) to reduce correlation with the intercept, consider covariance between slopes and intercept or constrain parameters using more informative priors (e.g. high or low LAD ?) -->

<!-- **We may miss some important environmental factors in this study.** One hypothesis is that LAD could be highly dependent on variables that we do not consider, such as the tree sanitary health or the site water availability. Here, it may not be possible to consider a climatic effect, because the intra-origin variability in climate may not be sufficient (for example, the 24 Cloture sites are located in the same area). The effect of climate may be contained within the origin random effect, that may also account for other environmental constraints and the protocol effect. -->

<!-- **We could imagine** **another index of competition such as dbh/dg**, which represents more a relative index of competition (i.e. a status within the stand), rather than an absolute index such as BALh. Moreover, the effects are linear, but we could imagine transformations to model for example a plateau effect for competition ? -->


<!-- # Perspectives -->

<!-- Once we are satisfied with the modelling approach, we will study the ecological mechanisms that could underlie the differences between species. Do species with different shade tolerance have different leaf area densities? Do they react differently to competition? **Ecological assumptions still have to be made.** -->
